main {
    /*defer { print("A: " ~ a as string); }
    let a = 5;
    func() {
        let b = 6;
        defer { print("B: " ~ b as string); }
        func() {
            defer { print("C: " ~ c as string); }
            let c = 7;
            kill
        }();
    }();*/
    unless(false) {
        print("A");
    }
    else unless(false) {
        print("B");
    }
}

    /*func() {
        int i = 5;
        
    }();*/
    //func() {
     //   defer { print("B"); }
    //    return
    //}();
    //panic "Hey";
    

    //panic "Error";


    /*try {
        raise Error, "Hello World !";
        panic "No";
    }
    rescue(err, msg) {
        print("catch: ");
    }*/
/*
func() {
    print("1");
    defer {
        print("defer");
    }
    print("2");
    return;
}

0   localstack  0
1   reg_defer   8
2   const.s     "1"
3   call_prim   print(string)
   raise
4   const.s     "2"
5   call_prim   print(string)
6   call_defer
7   ret
8   const.s     "defer"
9   call_prim   print(string)
10  ret_defer

Todo:
    - defer
    - try/catch
    - raise
    - panic
*/

/*
Todo:
    - déclaration d'une variable locale et d'une fonction du même nom

    Suggestions:
    Système de channel comme mosaiq
    raise "Error" try catch finally
    Variables globales

    kill
*/
/*
main {
    func() func(int) foo;
    
    foo = &test;
    func(int) p = foo();
    p(5);
}

func test() func(int) {
    let a = func(int t) {
        print(t);
    };
    return a;
}

*/

/*
    Structures

    struct Foo {
        int a; //register 0 int
        float b; //register 1 float
        bool c; //register 2 bool
    }

    main {
        Foo foo;
        foo.a //parse identifier avec opérateur '.'
        //On récupère le type Foo et récupère a dans Foo
        //comme une variable locale dans une fonction
    }

*/
/*
struct vec2 {
    float x;
    float y;
}

vec2 v;//register 2 int
v.x = 0;
v.y = 0;
*/



/*To do:
    (x) vec2 a = b;
    () a = [2.0, 5.0];
    () return a;
*/