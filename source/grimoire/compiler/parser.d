/**
    The parser analyses the lexemes generated by the lexer and produce machine code.

    Copyright: (c) Enalye 2018
    License: Zlib
    Authors: Enalye
*/

module grimoire.compiler.parser;

import std.stdio;
import std.string;
import std.array;
import std.conv;
import std.math;
import std.file;
import std.meta;

import grimoire.runtime;
import grimoire.assembly;
import grimoire.compiler.lexer;
import grimoire.compiler.mangle;
import grimoire.compiler.type;
import grimoire.compiler.primitive;

/**
    Analyses the syntax and produce the data for the VM
*/
class GrParser {
	int[] iconsts;
	float[] fconsts;
	dstring[] sconsts;

	uint scopeLevel;

	GrVariable[dstring] globalVariables;
    uint globalVariableIndex;
    uint[] globalFreeVariables;

	GrFunction[dstring] functions, events;
	GrFunction[] anonymousFunctions;

	uint current;
	GrFunction currentFunction;
	GrFunction[] functionStack;
	GrFunctionCall[] functionCalls;

	uint[][] breaksJumps;
	uint[][] continuesJumps;
	uint[] continuesDestinations;

	GrLexeme[] lexemes;

    bool isTypeChecking;

    /// Reset to the start of the sequence.
	void reset() {
		current = 0u;
	}

    /// Advance to the next lexeme.
	void advance() {
		if(current < lexemes.length)
			current ++;
	}

    /// Return to the last lexeme.
    void goBack() {
        if(current > 0u)
            current --;
    }

    /// Check for the end the sequence, then advance to the next lexeme.
	bool checkAdvance() {
		if(isEnd())
			return false;
		
		advance();
		return true;
	}

    /// Start of a block with `{`
	void openBlock() {
		scopeLevel ++;
	}

    /// End of a block with '}'
	void closeBlock() {
		scopeLevel --;
	}

    /// Check for the end of the sequence.
	bool isEnd(int offset = 0) {
		return (current + offset) >= cast(uint)lexemes.length;
	}

    /// Return the lexeme at the current position.
	GrLexeme get(int offset = 0) {
		uint position = current + offset;
		if(position < 0 || position >= cast(uint)lexemes.length) {
			logError("Unexpected end of file");
		}
		return lexemes[position];
	}

    /// Register an integral value and returns its id.
	uint registerIntConstant(int value) {
		foreach(size_t index, int iconst; iconsts) {
			if(iconst == value)
				return cast(uint)index;
		}
		iconsts ~= value;
		return cast(uint)iconsts.length - 1;
	}

    /// Register an floating point value and returns its id.
	uint registerFloatConstant(float value) {
		foreach(size_t index, float fconst; fconsts) {
			if(fconst == value)
				return cast(uint)index;
		}
		fconsts ~= value;
		return cast(uint)fconsts.length - 1;
	}

    /// Register an string value and returns its id.
	uint registerStringConstant(dstring value) {
		foreach(size_t index, dstring sconst; sconsts) {
			if(sconst == value)
				return cast(uint)index;
		}
		sconsts ~= value;
		return cast(uint)sconsts.length - 1;
	}

    /// Register a special local variable, used for iterators, etc.
	GrVariable registerSpecialVariable(dstring name, GrType type) {
		name = "~"d ~ name;
		GrVariable specialVariable;
		auto previousVariable = (name in currentFunction.localVariables);
		if(previousVariable is null)
			specialVariable = registerLocalVariable(name, type);
		else
			specialVariable = *previousVariable;
        specialVariable.isAuto = false;
        specialVariable.isInitialized = true; //We shortcut this check
		return specialVariable;
	}

    /// Register a global variable
    GrVariable registerGlobalVariable(dstring name, GrType type) {
        if(type.baseType == GrBaseType.TupleType) {
            //Register each field
            auto tuple = grGetTuple(type.mangledType);
            for(int i; i < tuple.signature.length; i ++) {
                registerLocalVariable(name ~ ":" ~ tuple.fields[i], tuple.signature[i]);
            }
            //Register the struct itself with the id of the first field
            auto previousVariable = (name in globalVariables);
            if(previousVariable !is null)
                logError("Multiple declaration", "The global variable \'" ~ to!string(name) ~ "\' is already declared.");

            GrVariable variable = new GrVariable;
            variable.index = globalVariableIndex;
            variable.isGlobal = true;
            variable.isInitialized = false;
            variable.type = type;
            variable.name = name;
            globalVariables[name] = variable;

            return variable;
        }

        //Check if declared globally.
		auto previousVariable = (name in globalVariables);
		if(previousVariable !is null)
			logError("Multiple declaration", "The global variable \'" ~ to!string(name) ~ "\' is already declared.");

		GrVariable variable = new GrVariable;
        if(globalFreeVariables.length) {
            variable.index = globalFreeVariables[$ - 1];
            globalFreeVariables.length --;
        }
        else {
            variable.index = globalVariableIndex;
            globalVariableIndex ++;
        }
		variable.isGlobal = true;
        variable.isInitialized = false;
		variable.type = type;
        variable.name = name;
		globalVariables[name] = variable;

		return variable;
    }

    /// Register a local variable
	GrVariable registerLocalVariable(dstring name, GrType type) {
        if(type.baseType == GrBaseType.TupleType) {
            //Register each field
            auto tuple = grGetTuple(type.mangledType);
            for(int i; i < tuple.signature.length; i ++) {
                registerLocalVariable(name ~ ":" ~ tuple.fields[i], tuple.signature[i]);
            }
            //Register the struct itself with the id of the first field
            auto previousVariable = (name in currentFunction.localVariables);
            if(previousVariable !is null)
                logError("Multiple declaration", "The local variable \'" ~ to!string(name) ~ "\' is already declared.");

            GrVariable variable = new GrVariable;
            variable.index = currentFunction.localVariableIndex;
            variable.isGlobal = false;
            variable.type = type;
            variable.name = name;
            currentFunction.localVariables[name] = variable;

            return variable;
        }
		//Check if declared globally
        if(name in globalVariables)
			logError("Multiple declaration", "The local variable \'" ~ to!string(name) ~ "\' is already declared in a global scope.");

		//Check if declared locally.
		auto previousVariable = (name in currentFunction.localVariables);
		if(previousVariable !is null)
			logError("Multiple declaration", "The local variable \'" ~ to!string(name) ~ "\' is already declared.");

		GrVariable variable = new GrVariable;
        if(currentFunction.localFreeVariables.length) {
            variable.index = currentFunction.localFreeVariables[$ - 1];
            currentFunction.localFreeVariables.length --;
        }
        else {
		    variable.index = currentFunction.localVariableIndex;
            currentFunction.localVariableIndex ++;
        }
		variable.isGlobal = false;
		variable.type = type;
        variable.name = name;
		currentFunction.localVariables[name] = variable;

		return variable;
	}

    void beginGlobalScope() {
        auto globalScope = "@global"d in functions;
        if(globalScope) {
            functionStack ~= currentFunction;
            currentFunction = *globalScope;
        }
        else {
            GrFunction func = new GrFunction;
            func.name = "@global"d;
            func.isTask = false;
            func.inSignature = [];
            func.outSignature = [];
            functions["@global"d] = func;
            functionStack ~= currentFunction;
            currentFunction = func;
        }
    }

    void endGlobalScope() {
        if(!functionStack.length)
			logError("Global Scope", "Global scope mismatch");
        
		currentFunction = functionStack[$ - 1];
        functionStack.length --;
    }

	void beginFunction(dstring name, GrType[] signature, bool isEvent = false) {
        const dstring mangledName = grMangleNamedFunction(name, signature);

		GrFunction* func;
        if(isEvent)
            func = mangledName in events;
        else
            func = mangledName in functions;

		if(func is null)
			logError("Undeclared function", "The function \'" ~ to!string(name) ~ "\' is not declared.");

		functionStack ~= currentFunction;
		currentFunction = *func;
	}

	void preBeginFunction(dstring name, GrType[] signature, dstring[] inputVariables, bool isTask, GrType[] outSignature = [], bool isAnonymous = false, bool isEvent = false) {
		GrFunction func = new GrFunction;
		func.isTask = isTask;
		func.inSignature = signature;
		func.outSignature = outSignature;

		if(isAnonymous) {
			func.index = cast(uint)anonymousFunctions.length;
			func.anonParent = currentFunction;
			func.anonReference = cast(uint)currentFunction.instructions.length;
			func.name = currentFunction.name ~ "@anon"d ~ to!dstring(func.index);
			anonymousFunctions ~= func;

			//Is replaced by the addr of the function later (see solveFunctionCalls).
			addInstruction(GrOpcode.LocalStore_Int, 0u);
		}
		else {
			func.index = cast(uint)functions.length;
			func.name = name;

			dstring mangledName = grMangleNamedFunction(name, signature);
			auto previousFunc = (mangledName in functions);
			if(previousFunc !is null)
				logError("Multiple declaration", "The function \'" ~ to!string(name) ~ "\' is already declared.");
		
            if(isEvent)
			    events[mangledName] = func;
            else
			    functions[mangledName] = func;
		}

		functionStack ~= currentFunction;
		currentFunction = func;

		addInstruction(GrOpcode.LocalStack, 0u);

		void fetchParameter(dstring name, GrType type) {
            final switch(type.baseType) with(GrBaseType) {
            case VoidType:
                logError("Invalid type", "Void is not a valid parameter type");
                break;
            case IntType:
            case BoolType:
            case FunctionType:
            case TaskType:
                func.nbIntegerParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_Int, 0u);
                break;
            case FloatType:
                func.nbFloatParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_Float, 0u);
                break;
            case StringType:
                func.nbStringParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_String, 0u);
                break;
            case VariantType:
                func.nbVariantParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_Variant, 0u);
                break;
            case TupleType:
                auto tuple = grGetTuple(type.mangledType);
                const auto nbFields = tuple.signature.length;
                for(int i = 1; i <= tuple.signature.length; i ++) {
                    fetchParameter(name ~ ":" ~ tuple.fields[nbFields - i], tuple.signature[nbFields - i]);
                }
                break;
            case StructType:
            case ArrayType:
            case UserType:
                func.nbUserDataParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_UserData, 0u);
                break;
            case InternalTupleType:
                throw new Exception("Tuples should not exist here.");
            }

            GrVariable newVar = new GrVariable;
            newVar.type = type;
            newVar.isInitialized = true;
            newVar.index = func.localVariableIndex;
            if(type.baseType != GrBaseType.TupleType)
                func.localVariableIndex ++;
            newVar.isGlobal = false;
            newVar.name = name;
            func.localVariables[name] = newVar;
            if(type.baseType != GrBaseType.TupleType)
                addSetInstruction(newVar);
        }

        foreach_reverse(size_t i, inputVariable; inputVariables) {
            fetchParameter(inputVariables[i], signature[i]);
        }
	}

	void endFunction() {
		setInstruction(GrOpcode.LocalStack, 0u, currentFunction.localVariableIndex);
		if(!functionStack.length)
			logError("Missing symbol", "A \'}\' is missing, causing a mismatch");
        
		currentFunction = functionStack[$ - 1];
        functionStack.length --;
	}

	void preEndFunction() {
		if(!functionStack.length)
			logError("Missing symbol", "A \'}\' is missing, causing a mismatch");
		currentFunction = functionStack[$ - 1];
        functionStack.length --;
	}

	GrFunction* getFunction(dstring name) {
		auto func = (name in functions);
		if(func is null)
			logError("Undeclared function", "The function \'" ~ to!string(name) ~ "\' is not declared");
		return func;
	}

    /// Retrieve a declared variable
	GrVariable getVariable(dstring name) {
        auto var = (name in globalVariables);
		if(var !is null)
            return *var;

		var = (name in currentFunction.localVariables);
		if(var is null)
            logError("Undeclared variable", "The variable \'" ~ to!string(name) ~ "\' is not declared");
        return *var;
	}

	void addIntConstant(int value) {
		addInstruction(GrOpcode.Const_Int, registerIntConstant(value));
	}

	void addFloatConstant(float value) {
		addInstruction(GrOpcode.Const_Float, registerFloatConstant(value));
	}

	void addBoolConstant(bool value) {
		addInstruction(GrOpcode.Const_Bool, value);
	}

	void addStringConstant(dstring value) {
		addInstruction(GrOpcode.Const_String, registerStringConstant(value));
	}

    void addMetaConstant(dstring value) {
		addInstruction(GrOpcode.Const_Meta, registerStringConstant(value));
    }

	void addInstruction(GrOpcode opcode, int value = 0, bool isSigned = false) {
		if(currentFunction is null)
			logError("Not in function", "The expression is located outside of a function or task, which is forbidden");

		GrInstruction instruction;
		instruction.opcode = opcode;
		if(isSigned) {
			if((value >= 0x800000) || (-value >= 0x800000))
				logError("Internal failure", "An opcode\'s signed value is exceeding limits");		
			instruction.value = value + 0x800000;
		}
		else
			instruction.value = value;
		currentFunction.instructions ~= instruction;
	}

	void setInstruction(GrOpcode opcode, uint index, int value = 0u, bool isSigned = false) {
		if(currentFunction is null)
			logError("Not in function", "The expression is located outside of a function or task, which is forbidden");

		if(index >= currentFunction.instructions.length)
			logError("Internal failure", "An instruction's index is exeeding the function size");

		GrInstruction instruction;
		instruction.opcode = opcode;
		if(isSigned) {
			if((value >= 0x800000) || (-value >= 0x800000))
				logError("Internal failure", "An opcode\'s signed value is exceeding limits");				
			instruction.value = value + 0x800000;
		}
		else
			instruction.value = value;
		currentFunction.instructions[index] = instruction;
	}

    bool isBinaryOperator(GrLexemeType lexType) {
        if(lexType >= GrLexemeType.Add && lexType <= GrLexemeType.Xor)
            return true;
        else
            return false;
    }

    bool isUnaryOperator(GrLexemeType lexType) {
        if(lexType >= GrLexemeType.Plus && lexType <= GrLexemeType.Minus)
            return true;
        else if(lexType >= GrLexemeType.Increment && lexType <= GrLexemeType.Decrement)
            return true;
        else if(lexType == GrLexemeType.Not)
            return true;
        else
            return false;
    }

    GrType addCustomBinaryOperator(GrLexemeType lexType, GrType leftType, GrType rightType) {
        GrType resultType = GrBaseType.VoidType;
        dstring mangledName = grMangleNamedFunction("@op_" ~ grGetPrettyLexemeType(lexType), [leftType, rightType]);
        
        //GrPrimitive check
        if(grIsPrimitiveDeclared(mangledName)) {
            GrPrimitive primitive = grGetPrimitive(mangledName);
            addInstruction(GrOpcode.PrimitiveCall, primitive.index);
            if(primitive.outSignature.length != 1uL)
                    logError("Return signature error", "An operator can only have one return value");
            resultType = primitive.outSignature[0];
        }

        //GrFunction check
        if(resultType.baseType == GrBaseType.VoidType) {
    		const auto func = (mangledName in functions);
            if(func !is null) {
                auto outSignature = addFunctionCall(mangledName);
                if(outSignature.length != 1uL)
                    logError("Return signature error", "An operator can only have one return value");
                resultType = outSignature[0];
            }
        }

        return resultType;     
    }

    GrType addCustomUnaryOperator(GrLexemeType lexType, GrType type) {
        GrType resultType = GrBaseType.VoidType;
        dstring mangledName = grMangleNamedFunction("@op_" ~ grGetPrettyLexemeType(lexType), [type]);
        
        //GrPrimitive check
        if(grIsPrimitiveDeclared(mangledName)) {
            GrPrimitive primitive = grGetPrimitive(mangledName);
            addInstruction(GrOpcode.PrimitiveCall, primitive.index);
            if(primitive.outSignature.length != 1uL)
                    logError("Return signature error", "An operator can only have one return value");
            resultType = primitive.outSignature[0];
        }

        //GrFunction check
        if(resultType.baseType == GrBaseType.VoidType) {
    		const auto func = (mangledName in functions);
            if(func !is null) {
                auto outSignature = addFunctionCall(mangledName);
                if(outSignature.length != 1uL)
                    logError("Return signature error", "An operator can only have one return value");
                resultType = outSignature[0];
            }
        }

        return resultType;     
    }

    GrType addBinaryOperator(GrLexemeType lexType, GrType leftType, GrType rightType) {
        if(leftType.baseType == GrBaseType.InternalTupleType || rightType.baseType == GrBaseType.InternalTupleType)
            logError("Multiple values operation", "Cannot use an operator on an expression list");
        GrType resultType = GrBaseType.VoidType;

        if(leftType != rightType) {
            //Check custom operator
            resultType = addCustomBinaryOperator(lexType, leftType, rightType);

            //If there is no custom operator defined, we try to convert and then try again
            if(resultType.baseType == GrBaseType.VoidType) {
                resultType = convertType(rightType, leftType, true);
                if(resultType.baseType != GrBaseType.VoidType) {
                    resultType = addBinaryOperator(lexType, resultType, resultType);
                }
            }
        }
        else {
            resultType = addInternalOperator(lexType, leftType);
            if(resultType.baseType == GrBaseType.VoidType) {
                resultType = addCustomBinaryOperator(lexType, leftType, rightType);
            }
        }
        
        if(resultType.baseType == GrBaseType.VoidType)
            logError("Operator Undefined", "There is no "
                ~ to!string(grGetPrettyLexemeType(lexType))
                ~ " operator defined for \'"
                ~ grGetPrettyType(leftType)
                ~ "\' and \'"
                ~ grGetPrettyType(rightType)
                ~ "\'");
        return resultType;
    }

    GrType addUnaryOperator(GrLexemeType lexType, GrType type) {
        if(type.baseType == GrBaseType.InternalTupleType)
            logError("Multiple values operation", "Cannot use an operator on an expression list");
        GrType resultType = GrBaseType.VoidType;
        
        resultType = addInternalOperator(lexType, type);
        if(resultType.baseType == GrBaseType.VoidType) {
            resultType = addCustomUnaryOperator(lexType, type);
        }
    
        if(resultType.baseType == GrBaseType.VoidType)
            logError("Operator Undefined", "There is no "
                ~ to!string(grGetPrettyLexemeType(lexType))
                ~ " operator defined for \'"
                ~ grGetPrettyType(type)
                ~ "\'");
        return resultType;
    }

	GrType addOperator(GrLexemeType lexType, ref GrType[] typeStack) {
        if(isBinaryOperator(lexType)) {
            typeStack[$ - 2] = addBinaryOperator(lexType, typeStack[$ - 2], typeStack[$ - 1]);
            typeStack.length --;
            return typeStack[$ - 1];
        }
        else if(isUnaryOperator(lexType)) {
            typeStack[$ - 1] = addUnaryOperator(lexType, typeStack[$ - 1]);
            return typeStack[$ - 1];
        }

        return GrType(GrBaseType.VoidType);		
	}

    GrType addInternalOperator(GrLexemeType lexType, GrType varType) {
        switch(varType.baseType) with(GrBaseType) {
        case BoolType:
            switch(lexType) with(GrLexemeType) {
            case And:
				addInstruction(GrOpcode.And_Int);
                return GrType(GrBaseType.BoolType);
			case Or:
				addInstruction(GrOpcode.Or_Int);
                return GrType(GrBaseType.BoolType);
			case Not:
				addInstruction(GrOpcode.Not_Int);
                return GrType(GrBaseType.BoolType);				
            default:
                break;
            }
            break;
		case IntType:
			switch(lexType) with(GrLexemeType) {
			case Add:
				addInstruction(GrOpcode.Add_Int);
				return GrType(GrBaseType.IntType);
			case Substract:
				addInstruction(GrOpcode.Substract_Int);
				return GrType(GrBaseType.IntType);
			case Multiply:
				addInstruction(GrOpcode.Multiply_Int);
				return GrType(GrBaseType.IntType);
			case Divide:
				addInstruction(GrOpcode.Divide_Int);
				return GrType(GrBaseType.IntType);
            case Remainder:
				addInstruction(GrOpcode.Remainder_Int);
				return GrType(GrBaseType.IntType);
			case Minus:
				addInstruction(GrOpcode.Negative_Int);
				return GrType(GrBaseType.IntType);
			case Plus:
				return GrType(GrBaseType.IntType);
			case Increment:
				addInstruction(GrOpcode.Increment_Int);
				return GrType(GrBaseType.IntType);
			case Decrement:
				addInstruction(GrOpcode.Decrement_Int);
				return GrType(GrBaseType.IntType);
			case Equal:
				addInstruction(GrOpcode.Equal_Int);
				return GrType(GrBaseType.BoolType);
			case NotEqual:
				addInstruction(GrOpcode.NotEqual_Int);
				return GrType(GrBaseType.BoolType);
			case Greater:
				addInstruction(GrOpcode.Greater_Int);
				return GrType(GrBaseType.BoolType);
			case GreaterOrEqual:
				addInstruction(GrOpcode.GreaterOrEqual_Int);
				return GrType(GrBaseType.BoolType);
			case Lesser:
				addInstruction(GrOpcode.Lesser_Int);
				return GrType(GrBaseType.BoolType);
			case LesserOrEqual:
				addInstruction(GrOpcode.LesserOrEqual_Int);
                return GrType(GrBaseType.BoolType);				
			default:
				break;
			}
			break;
		case FloatType:
			switch(lexType) with(GrLexemeType) {
			case Add:
				addInstruction(GrOpcode.Add_Float);
				return GrType(GrBaseType.FloatType);
			case Substract:
				addInstruction(GrOpcode.Substract_Float);
				return GrType(GrBaseType.FloatType);
			case Multiply:
				addInstruction(GrOpcode.Multiply_Float);
				return GrType(GrBaseType.FloatType);
			case Divide:
				addInstruction(GrOpcode.Divide_Float);
				return GrType(GrBaseType.FloatType);
            case Remainder:
				addInstruction(GrOpcode.Remainder_Float);
				return GrType(GrBaseType.FloatType);
			case Minus:
				addInstruction(GrOpcode.Negative_Float);
				return GrType(GrBaseType.FloatType);
			case Plus:
				return GrType(GrBaseType.FloatType);
			case Increment:
				addInstruction(GrOpcode.Increment_Float);
				return GrType(GrBaseType.FloatType);
			case Decrement:
				addInstruction(GrOpcode.Decrement_Float);
				return GrType(GrBaseType.FloatType);
			case Equal:
				addInstruction(GrOpcode.Equal_Float);
				return GrType(GrBaseType.BoolType);
			case NotEqual:
				addInstruction(GrOpcode.NotEqual_Float);
				return GrType(GrBaseType.BoolType);
			case Greater:
				addInstruction(GrOpcode.Greater_Float);
				return GrType(GrBaseType.BoolType);
			case GreaterOrEqual:
				addInstruction(GrOpcode.GreaterOrEqual_Float);
				return GrType(GrBaseType.BoolType);
			case Lesser:
				addInstruction(GrOpcode.Lesser_Float);
				return GrType(GrBaseType.BoolType);
			case LesserOrEqual:
				addInstruction(GrOpcode.LesserOrEqual_Float);
				return GrType(GrBaseType.BoolType);
			default:
				break;
			}
			break;
		case StringType:
			switch(lexType) with(GrLexemeType) {
			case Concatenate:
				addInstruction(GrOpcode.Concatenate_String);
				return GrType(GrBaseType.StringType);
			case Equal:
				addInstruction(GrOpcode.Equal_String);
				return GrType(GrBaseType.BoolType);
			case NotEqual:
				addInstruction(GrOpcode.NotEqual_String);
				return GrType(GrBaseType.BoolType);
			default:
				break;
			}
			break;
		case VariantType:
			switch(lexType) with(GrLexemeType) {
			case Add:
				addInstruction(GrOpcode.Add_Variant);
				return GrType(GrBaseType.VariantType);
			case Substract:
				addInstruction(GrOpcode.Substract_Variant);
				return GrType(GrBaseType.VariantType);
			case Multiply:
				addInstruction(GrOpcode.Multiply_Variant);
				return GrType(GrBaseType.VariantType);
			case Divide:
				addInstruction(GrOpcode.Divide_Variant);
				return GrType(GrBaseType.VariantType);
            case Remainder:
				addInstruction(GrOpcode.Remainder_Variant);
				return GrType(GrBaseType.VariantType);
			case Minus:
				addInstruction(GrOpcode.Negative_Variant);
				return GrType(GrBaseType.VariantType);
			case Plus:
				return GrType(GrBaseType.VariantType);
			case Increment:
				addInstruction(GrOpcode.Increment_Variant);
				return GrType(GrBaseType.VariantType);
			case Decrement:
				addInstruction(GrOpcode.Decrement_Variant);
				return GrType(GrBaseType.VariantType);
			case Concatenate:
				addInstruction(GrOpcode.Concatenate_Variant);
				return GrType(GrBaseType.VariantType);
			case Equal:
				addInstruction(GrOpcode.Equal_Variant);
				return GrType(GrBaseType.BoolType);
			case NotEqual:
				addInstruction(GrOpcode.NotEqual_Variant);
				return GrType(GrBaseType.BoolType);
			case Greater:
				addInstruction(GrOpcode.Greater_Variant);
				return GrType(GrBaseType.BoolType);
			case GreaterOrEqual:
				addInstruction(GrOpcode.GreaterOrEqual_Variant);
				return GrType(GrBaseType.BoolType);
			case Lesser:
				addInstruction(GrOpcode.Lesser_Variant);
				return GrType(GrBaseType.BoolType);
			case LesserOrEqual:
				addInstruction(GrOpcode.LesserOrEqual_Variant);
				return GrType(GrBaseType.BoolType);
			case And:
				addInstruction(GrOpcode.And_Variant);
				return GrType(GrBaseType.BoolType);
			case Or:
				addInstruction(GrOpcode.Or_Variant);
				return GrType(GrBaseType.BoolType);
			case Not:
				addInstruction(GrOpcode.Not_Variant);
				return GrType(GrBaseType.VariantType);
			default:
				break;
			}
			break;
		default:
            break;
		}
        return GrType(GrBaseType.VoidType);
    }

	void addSetInstruction(GrVariable variable, GrType valueType = GrType(GrBaseType.VoidType), bool isGettingValue = false) {
        if(variable is null) {
            convertType(valueType, grVariant);
			addInstruction(isGettingValue ? GrOpcode.LocalStore2_Ref : GrOpcode.LocalStore_Ref);
            return;
        }
        
        if(variable.isAuto && !variable.isInitialized) {
            variable.isInitialized = true;
            variable.isAuto = false;
            variable.type = valueType;
            if(valueType.baseType == GrBaseType.TupleType) {
                auto tuple = grGetTuple(valueType.mangledType);
                if(variable.isGlobal) {
                    globalFreeVariables ~= variable.index;
                    for(int i; i < tuple.signature.length; i ++) {
                        registerGlobalVariable(variable.name ~ ":" ~ tuple.fields[i], tuple.signature[i]);
                    }
                }
                else {
                    currentFunction.localFreeVariables ~= variable.index;
                    for(int i; i < tuple.signature.length; i ++) {
                        registerLocalVariable(variable.name ~ ":" ~ tuple.fields[i], tuple.signature[i]);
                    }
                }
            }
            else if(valueType.baseType == GrBaseType.VoidType)
                logError("GrVariable type error", "Cannot infer the type of variable");
        }
        
        if(valueType.baseType != GrBaseType.VoidType)
            convertType(valueType, variable.type);

        //if(!variable.isInitialized && isGettingValue)
        //    logError("Uninitialized variable", "The variable is being used without being assigned");
        variable.isInitialized = true;

        if(variable.isField) {
            switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
				addInstruction(GrOpcode.FieldStore_Int, isGettingValue ? 0 : -1, true);
				break;
            default:
				logError("Invalid type", "Cannot assign to a \'" ~ to!string(variable.type) ~ "\' type");
			} 
        }
		else if(variable.isGlobal) {
			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_Int : GrOpcode.GlobalStore_Int, variable.index);
				break;
			case FloatType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_Float : GrOpcode.GlobalStore_Float, variable.index);
				break;
			case StringType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_String : GrOpcode.GlobalStore_String, variable.index);
				break;
			case VariantType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_Variant : GrOpcode.GlobalStore_Variant, variable.index);
				break;
			case StructType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_UserData : GrOpcode.GlobalStore_UserData, variable.index);
				break;
            case TupleType:
                auto tuple = grGetTuple(variable.type.mangledType);
                const auto nbFields = tuple.signature.length;
                for(int i = 1; i <= nbFields; i ++) {
                    addSetInstruction(getVariable(variable.name ~ ":" ~ tuple.fields[nbFields - i]), tuple.signature[nbFields - i], isGettingValue);
                }
                break;
            case ArrayType:
            case UserType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_UserData : GrOpcode.GlobalStore_UserData, variable.index);
				break;
			default:
				logError("Invalid type", "Cannot assign to a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
		else {
			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_Int : GrOpcode.LocalStore_Int, variable.index);
				break;
			case FloatType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_Float : GrOpcode.LocalStore_Float, variable.index);
				break;
			case StringType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_String : GrOpcode.LocalStore_String, variable.index);
				break;
			case VariantType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_Variant : GrOpcode.LocalStore_Variant, variable.index);
				break;
			case StructType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_UserData : GrOpcode.LocalStore_UserData, variable.index);
				break;
            case TupleType:
                auto tuple = grGetTuple(variable.type.mangledType);
                const auto nbFields = tuple.signature.length;
                for(int i = 1; i <= nbFields; i ++) {
                    addSetInstruction(getVariable(variable.name ~ ":" ~ tuple.fields[nbFields - i]), tuple.signature[nbFields - i]);
                }
                if(isGettingValue)
                    shiftStackPosition(variable.type, 1);
                break;
            case ArrayType:
            case UserType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_UserData : GrOpcode.LocalStore_UserData, variable.index);
				break;
			default:
				logError("Invalid type", "Cannot assign to a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
	}

	void addGetInstruction(GrVariable variable, GrType expectedType = GrType(GrBaseType.VoidType), bool allowOptimization = true) {
        /*
            BUG: This shouldn't be optimized as it will crash the VM.
            "main {
                bool a = true;
                loop {
                    if(a) {}
                    yield
                }
            }"
            To avoid that, we disallow optimization until this is fixed.
        */
        allowOptimization = false;
        //--------

        if(variable.isField) {
            logError("Internal error", "Attempt to get field value");
        }
        else if(variable.isGlobal) {
			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.GlobalStore_Int
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.GlobalStore2_Int;
                else
				    addInstruction(GrOpcode.GlobalLoad_Int, variable.index);
				break;
			case FloatType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.GlobalStore_Float
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.GlobalStore2_Float;
                else
			    	addInstruction(GrOpcode.GlobalLoad_Float, variable.index);
				break;
			case StringType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.GlobalStore_String
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.GlobalStore2_String;
                else
				    addInstruction(GrOpcode.GlobalLoad_String, variable.index);
				break;
			case VariantType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.GlobalStore_Variant
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.GlobalStore2_Variant;
                else
				    addInstruction(GrOpcode.GlobalLoad_Variant, variable.index);
				break;
			case StructType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.GlobalStore_UserData
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.GlobalStore2_UserData;
                else			
			    	addInstruction(GrOpcode.GlobalLoad_UserData, variable.index);
				break;
            case TupleType:
                auto tuple = grGetTuple(variable.type.mangledType);
                for(int i; i < tuple.signature.length; i ++) {
                    addGetInstruction(getVariable(variable.name ~ ":" ~ tuple.fields[i]), tuple.signature[i]);
                }
                break;
            case ArrayType:
            case UserType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.GlobalStore_UserData
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.GlobalStore2_UserData;
                else			
			    	addInstruction(GrOpcode.GlobalLoad_UserData, variable.index);
				break;
			default:
				logError("Invalid type", "Cannot fetch from a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
		else {
            if(!variable.isInitialized)
                logError("Uninitialized variable", "The local variable is being used without being assigned");

			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.LocalStore_Int
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.LocalStore2_Int;
                else
				    addInstruction(GrOpcode.LocalLoad_Int, variable.index);
				break;
			case FloatType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.LocalStore_Float
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.LocalStore2_Float;
                else
				    addInstruction(GrOpcode.LocalLoad_Float, variable.index);
				break;
			case StringType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.LocalStore_String
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.LocalStore2_String;
                else
				    addInstruction(GrOpcode.LocalLoad_String, variable.index);
				break;
			case VariantType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.LocalStore_Variant
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.LocalStore2_Variant;
                else
				    addInstruction(GrOpcode.LocalLoad_Variant, variable.index);
				break;
			case StructType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.LocalStore_UserData
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.LocalStore2_UserData;
                else			
				    addInstruction(GrOpcode.LocalLoad_UserData, variable.index);
				break;
            case TupleType:
                auto tuple = grGetTuple(variable.type.mangledType);
                for(int i; i < tuple.signature.length; i ++) {
                    addGetInstruction(getVariable(variable.name ~ ":" ~ tuple.fields[i]), tuple.signature[i]);
                }
                break;
            case ArrayType:
            case UserType:
                if(allowOptimization
                    && currentFunction.instructions[$ - 1].opcode == GrOpcode.LocalStore_UserData
                    && currentFunction.instructions[$ - 1].value == variable.index)
                    currentFunction.instructions[$ - 1].opcode = GrOpcode.LocalStore2_UserData;
                else	
				    addInstruction(GrOpcode.LocalLoad_UserData, variable.index);
				break;
			default:
				logError("Invalid type", "Cannot fetch from a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
	}

    GrType addFunctionAddress(dstring mangledName) {
        GrFunctionCall call = new GrFunctionCall;
		call.mangledName = mangledName;
		call.caller = currentFunction;
		functionCalls ~= call;
		currentFunction.functionCalls ~= call;
        call.isAddress = true;

		auto func = (call.mangledName in functions);
		if(func !is null) {
		    call.functionToCall = *func;
            call.isAddress = true;
            call.position = cast(uint)currentFunction.instructions.length;
            addInstruction(GrOpcode.Const_Int, 0);

            return grGetFunctionAsType(*func);
        }

		return GrType(GrBaseType.VoidType);
    }

	GrType[] addFunctionCall(dstring mangledName) {
		GrFunctionCall call = new GrFunctionCall;
		call.mangledName = mangledName;
		call.caller = currentFunction;
		functionCalls ~= call;
		currentFunction.functionCalls ~= call;
        call.isAddress = false;

		auto func = (call.mangledName in functions);
		if(func !is null) {
			call.functionToCall = *func;
            if(func.isTask) {
                if(func.nbIntegerParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_Int, func.nbIntegerParameters);
                if(func.nbFloatParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_Float, func.nbFloatParameters);
                if(func.nbStringParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_String, func.nbStringParameters);
                if(func.nbVariantParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_Variant, func.nbVariantParameters);
                if(func.nbUserDataParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_UserData, func.nbUserDataParameters);
            }

            call.position = cast(uint)currentFunction.instructions.length;
            addInstruction(GrOpcode.Call, 0);

			return func.outSignature;
		}
		else
			logError("Undeclared function", "The function \'" ~ to!string(call.mangledName) ~ "\' is not declared");

		return [];
	}

	void setOpcode(ref uint[] opcodes, uint position, GrOpcode opcode, uint value = 0u, bool isSigned = false) {
		GrInstruction instruction;
		instruction.opcode = opcode;
		if(isSigned) {
			if((value >= 0x800000) || (-value >= 0x800000))
				logError("Internal failure", "An opcode\'s signed value is exceeding limits");	
			instruction.value = value + 0x800000;
		}
		else
			instruction.value = value;

		uint makeOpcode(uint instr, uint value) {
			return ((value << 8u) & 0xffffff00) | (instr & 0xff);
		}
		opcodes[position] = makeOpcode(cast(uint)instruction.opcode, instruction.value);
	}

	void solveFunctionCalls(ref uint[] opcodes) {
		foreach(GrFunctionCall call; functionCalls) {
			auto func = (call.mangledName in functions);
			if(func !is null) {
                if(call.isAddress)
                    setOpcode(opcodes, call.position, GrOpcode.Const_Int, registerIntConstant(func.position));
				else if(func.isTask)
					setOpcode(opcodes, call.position, GrOpcode.Task, func.position);
				else
					setOpcode(opcodes, call.position, GrOpcode.Call, func.position);
			}
			else
				logError("Undeclared function", "The function \'" ~ to!string(call.mangledName) ~ "\' is not declared");
		}

		foreach(func; anonymousFunctions)
			setOpcode(opcodes, func.anonParent.position + func.anonReference, GrOpcode.Const_Int, registerIntConstant(func.position));
	}

	void dump() {
		writeln("Code Generated:\n");
		foreach(size_t i, int ivalue; iconsts)
			writeln(".iconst " ~ to!string(ivalue) ~ "\t;" ~ to!string(i));

		foreach(size_t i, float fvalue; fconsts)
			writeln(".fconst " ~ to!string(fvalue) ~ "\t;" ~ to!string(i));

		foreach(size_t i, dstring svalue; sconsts)
			writeln(".sconst " ~ to!string(svalue) ~ "\t;" ~ to!string(i));

		foreach(dstring funcName, GrFunction func; functions) {
			if(func.isTask)
				writeln("\n.task " ~ funcName);
			else
				writeln("\n.function " ~ funcName);

			foreach(size_t i, GrInstruction instruction; func.instructions) {
				writeln("[" ~ to!string(i) ~ "] " ~ to!string(instruction.opcode) ~ " " ~ to!string(instruction.value));
			}
		}
	}

	void parseScript(GrLexer lexer) {
		preParseScript(lexer);
		reset();

		lexemes = lexer.lexemes;

		while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Semicolon:
                checkAdvance();
                break;
            case Tuple:
            case Def:
                skipDeclaration();
                break;
			case Main:
				parseMainDeclaration();
				break;
            case Event:
                parseEventDeclaration();
                break;
			case TaskType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				parseTaskDeclaration();
				break;
			case FunctionType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				parseFunctionDeclaration();
				break;
            case VoidType: .. case VariantType:
            case AutoType:
            case Identifier:
                skipExpression();
                break;
			default:
				logError("Invalid type", "The type should be either main, func or task");
			}
		}
	}

	void preParseScript(GrLexer lexer) {
		lexemes = lexer.lexemes;

        //Tuple definitions
        while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Semicolon:
                checkAdvance();
                break;
            case Tuple:
                parseTupleDeclaration();
                break;
            case Def:
                parseStructDeclaration();
                break;
			case Main:
            case Event:
			case TaskType:
			case FunctionType:
				skipDeclaration();
				break;
			default:
				skipExpression();
                break;
			}
		}

        //Resolve all unresolved field types
        grResolveTupleSignature();
        grResolveStructSignature();

        //Then we can resolve primitives' signature
        grResolvePrimitiveSignature();
        
        //Function definitions
        reset();
		while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Semicolon:
                checkAdvance();
                break;
            case Tuple:
            case Def:
                skipDeclaration();
                break;
			case Main:
				preParseMainDeclaration();
				break;
            case Event:
                preParseEventDeclaration();
                break;
			case TaskType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				preParseTaskDeclaration();
				break;
			case FunctionType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				preParseFunctionDeclaration();
				break;
            case VoidType: .. case VariantType:
            case AutoType:
            case Identifier:
                skipExpression();
                break;
			default:
				logError("Invalid type", "The type should be either main, func, task or struct");
			}
		}

        //Global variable definitions
        reset();
        beginGlobalScope();
		while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Semicolon:
                checkAdvance();
                break;
            case Event:
            case Tuple:
            case Def:
			case Main:
				skipDeclaration();
				break;
			case TaskType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				skipDeclaration();
				break;
			case FunctionType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
    			skipDeclaration();
                break;
            case VoidType: .. case VariantType:
            case AutoType:
                parseGlobalDeclaration();
                break;
            case Identifier:
                if(grIsTuple(get().svalue) || grIsUserType(get().svalue)) {
                    parseGlobalDeclaration();
                    break;
                }
                goto default;
			default:
				logError("Invalid type", "The type should be either main, func, task or struct");
			}
		}
        endGlobalScope();
	}

    void parseTupleDeclaration() {
		checkAdvance();
        if(get().type != GrLexemeType.Identifier)
            logError("Missing Identifier", "struct must have a name");
        dstring structName = get().svalue;
        checkAdvance();
        if(get().type != GrLexemeType.LeftCurlyBrace)
            logError("Missing {", "struct does not have a body");
        checkAdvance();

        dstring[] fields;
        GrType[] signature;
        while(!isEnd()) {
            if(get().type == GrLexemeType.VoidType)
                logError("Field type error", "Void is not a valid field type");
            else if(get().type == GrLexemeType.RightCurlyBrace) {
                checkAdvance();
                break;
            }

            //Lazy check because we can't know about other tuples
            auto fieldType = parseType(false);
            do {
                if(get().type == GrLexemeType.Comma)
                    checkAdvance();

                //Unresolved type
                if(fieldType.baseType == GrBaseType.VoidType) {
                    fieldType.mangledType = get().svalue;
                    checkAdvance();
                }
                
                if(get().type != GrLexemeType.Identifier)
                    logError("Missing Identifier", "struct field must have a name");

                auto fieldName = get().svalue;
                checkAdvance();

                signature ~= fieldType;
                fields ~= fieldName;
            }
            while(get().type == GrLexemeType.Comma);

            if(get().type != GrLexemeType.Semicolon)
                logError("Missing semicolon", "A struct field declaration must end with a semicolon");
            checkAdvance();

            if(get().type == GrLexemeType.RightCurlyBrace) {
                checkAdvance();
                break;
            }
        }
        grAddTuple(structName, fields, signature);
    }


    void parseStructDeclaration() {
		checkAdvance();
        if(get().type != GrLexemeType.Identifier)
            logError("Missing Identifier", "struct must have a name");
        dstring structName = get().svalue;
        checkAdvance();
        if(get().type != GrLexemeType.LeftCurlyBrace)
            logError("Missing {", "struct does not have a body");
        checkAdvance();

        dstring[] fields;
        GrType[] signature;
        while(!isEnd()) {
            if(get().type == GrLexemeType.VoidType)
                logError("Field type error", "Void is not a valid field type");
            else if(get().type == GrLexemeType.RightCurlyBrace) {
                checkAdvance();
                break;
            }

            //Lazy check because we can't know about other structs
            auto fieldType = parseType(false);
            do {
                if(get().type == GrLexemeType.Comma)
                    checkAdvance();

                //Unresolved type
                if(fieldType.baseType == GrBaseType.VoidType) {
                    fieldType.mangledType = get().svalue;
                    checkAdvance();
                }
                
                if(get().type != GrLexemeType.Identifier)
                    logError("Missing Identifier", "struct field must have a name");

                auto fieldName = get().svalue;
                checkAdvance();

                signature ~= fieldType;
                fields ~= fieldName;
            }
            while(get().type == GrLexemeType.Comma);

            if(get().type != GrLexemeType.Semicolon)
                logError("Missing semicolon", "A struct field declaration must end with a semicolon");
            checkAdvance();

            if(get().type == GrLexemeType.RightCurlyBrace) {
                checkAdvance();
                break;
            }
        }
        grAddStruct(structName, fields, signature);
    }

    void skipDeclaration() {
        checkAdvance();
        while(!isEnd()) {
            if(get().type != GrLexemeType.LeftCurlyBrace) {
                checkAdvance();
            }
            else {
                skipBlock();
                return;
            }
        }
    }

    void skipExpression() {
        checkAdvance();
        while(!isEnd()) {
            switch(get().type) with(GrLexemeType) {
            case Semicolon:
                checkAdvance();
                return;
            case LeftCurlyBrace:
                skipBlock();
                break;
            default:
                checkAdvance();
                break;
            }
        }
    }

    GrType parseType(bool mustBeType = true) {
        GrType currentType = GrBaseType.VoidType;

        GrLexeme lex = get();
        if(!lex.isType) {
            if(lex.type == GrLexemeType.Identifier && grIsTuple(lex.svalue)) {
                currentType.baseType = GrBaseType.TupleType;
                currentType.mangledType = lex.svalue;
                checkAdvance();
                return currentType;
            }
            else if(lex.type == GrLexemeType.Identifier && grIsStruct(lex.svalue)) {
                currentType.baseType = GrBaseType.StructType;
                currentType.mangledType = lex.svalue;
                checkAdvance();
                return currentType;
            }
            else if(lex.type == GrLexemeType.Identifier && grIsUserType(lex.svalue)) {
                currentType.baseType = GrBaseType.UserType;
                currentType.mangledType = lex.svalue;
                checkAdvance();
                return currentType;
            }
            else if(mustBeType) {
                logError("Excepted type", "A valid type is expected");
            }
            else {
                return currentType;
            }
        }

        switch(lex.type) with(GrLexemeType) {
        case VoidType:
            currentType.baseType = GrBaseType.VoidType;
            checkAdvance();
            break;
        case IntType:
            currentType.baseType = GrBaseType.IntType;
            checkAdvance();
            break;
        case FloatType:
            currentType.baseType = GrBaseType.FloatType;
            checkAdvance();
            break;
        case BoolType:
            currentType.baseType = GrBaseType.BoolType;
            checkAdvance();
            break;
        case StringType:
            currentType.baseType = GrBaseType.StringType;
            checkAdvance();
            break;
        case ArrayType:
            currentType.baseType = GrBaseType.ArrayType;
            checkAdvance();
            break;
        case VariantType:
            currentType.baseType = GrBaseType.VariantType;
            checkAdvance();
            break;
        case FunctionType:
            currentType.baseType = GrBaseType.FunctionType;
            dstring[] temp; 
            currentType.mangledType = grMangleNamedFunction("", parseInSignature(temp, true));
            currentType.mangledReturnType = grMangleNamedFunction("", parseOutSignature());
            break;
        case TaskType:
            currentType.baseType = GrBaseType.TaskType;
            dstring[] temp; 
            currentType.mangledType = grMangleNamedFunction("", parseInSignature(temp, true));
            currentType.mangledReturnType = grMangleNamedFunction("", parseOutSignature());
            break;
        default:
            logError("Invalid type", "Cannot call a function with a parameter of type \'" ~ to!string(lex.type) ~ "\'");
        }

        return currentType;
    }

    void addGlobalPop(GrType type) {
        final switch(type.baseType) with(GrBaseType) {
        case VoidType:
            logError("Invalid type", "Void is not a valid parameter type");
            break;
        case IntType:
        case BoolType:
        case FunctionType:
        case TaskType:
            addInstruction(GrOpcode.GlobalPop_Int, 0u);
            break;
        case FloatType:
            addInstruction(GrOpcode.GlobalPop_Float, 0u);
            break;
        case StringType:
            addInstruction(GrOpcode.GlobalPop_String, 0u);
            break;
        case VariantType:
            addInstruction(GrOpcode.GlobalPop_Variant, 0u);
            break;
        case TupleType:
            auto tuple = grGetTuple(type.mangledType);
            for(int i; i < tuple.signature.length; i ++) {
                addGlobalPop(tuple.signature[i]);
            }
            break;
        case StructType:
        case ArrayType:
        case UserType:
            addInstruction(GrOpcode.GlobalPop_UserData, 0u);
            break;
        case InternalTupleType:
            throw new Exception("Tuples should not exist here.");
        }
    }

    void addGlobalPush(GrType type, int nbPush = 1u) {
        if(nbPush == 0)
            return;
        final switch(type.baseType) with(GrBaseType) {
        case VoidType:
            logError("Invalid type", "Void is not a valid parameter type");
            break;
        case IntType:
        case BoolType:
        case FunctionType:
        case TaskType:
            addInstruction(GrOpcode.GlobalPush_Int, nbPush);
            break;
        case FloatType:
            addInstruction(GrOpcode.GlobalPush_Float, nbPush);
            break;
        case StringType:
            addInstruction(GrOpcode.GlobalPush_String, nbPush);
            break;
        case VariantType:
            addInstruction(GrOpcode.GlobalPush_Variant, nbPush);
            break;
        case TupleType:
            auto tuple = grGetTuple(type.mangledType);
            for(int i = 1; i <= tuple.signature.length; i ++) {
                addGlobalPush(tuple.signature[tuple.signature.length - i], nbPush);
            }
            break;
        case StructType:
        case ArrayType:
        case UserType:
            addInstruction(GrOpcode.GlobalPush_UserData, nbPush);
            break;
        case InternalTupleType:
            throw new Exception("Tuples should not exist here.");
        }
    }

    void addGlobalPush(GrType[] signature) {
        struct TypeCounter {
            uint nbIntParams, nbFloatParams, nbStringParams,
                nbVariantParams, nbUserDataParams;
        }
        void countParameters(ref TypeCounter typeCounter, GrType type) {
            final switch(type.baseType) with(GrBaseType) {
            case VoidType:
                logError("Invalid type", "Void is not a valid parameter type");
                break;
            case IntType:
            case BoolType:
            case FunctionType:
            case TaskType:
                typeCounter.nbIntParams ++;
                break;
            case FloatType:
                typeCounter.nbFloatParams ++;
                break;
            case StringType:
                typeCounter.nbStringParams ++;
                break;
            case VariantType:
                typeCounter.nbVariantParams ++;
                break;
            case TupleType:
                auto tuple = grGetTuple(type.mangledType);
                for(int i = 1; i <= tuple.signature.length; i ++) {
                    countParameters(typeCounter, tuple.signature[tuple.signature.length - i]);
                }
                break;
            case StructType:
            case ArrayType:
            case UserType:
                typeCounter.nbUserDataParams ++;
                break;
            case InternalTupleType:
                throw new Exception("Tuples should not exist here.");
            }
        }

        TypeCounter typeCounter;
        foreach(type; signature) {
            countParameters(typeCounter, type);
        }

        if(typeCounter.nbIntParams > 0)
            addInstruction(GrOpcode.GlobalPush_Int, typeCounter.nbIntParams);
        if(typeCounter.nbFloatParams > 0)
            addInstruction(GrOpcode.GlobalPush_Float, typeCounter.nbFloatParams);
        if(typeCounter.nbStringParams > 0)
            addInstruction(GrOpcode.GlobalPush_String, typeCounter.nbStringParams);
        if(typeCounter.nbVariantParams > 0)
            addInstruction(GrOpcode.GlobalPush_Variant, typeCounter.nbVariantParams);
        if(typeCounter.nbUserDataParams > 0)
            addInstruction(GrOpcode.GlobalPush_UserData, typeCounter.nbUserDataParams);
    }

	GrType[] parseInSignature(ref dstring[] inputVariables, bool asType = false) {
		GrType[] inSignature;

		checkAdvance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A signature should always start with \'(\'");

        bool startLoop = true;
		for(;;) {
			checkAdvance();
			GrLexeme lex = get();

			if(startLoop && lex.type == GrLexemeType.RightParenthesis)
				break;
            startLoop = false;
            
            inSignature ~= parseType();

            //If we want to know whether it's a type or an anon, we can't throw exceptions.
            if(isTypeChecking) {
                lex = get();
                if(get().type == GrLexemeType.Identifier) {
                    inputVariables ~= lex.svalue;
                    checkAdvance();
                    lex = get();
                }
                
                if(lex.type == GrLexemeType.RightParenthesis)
                    break;
                else if(lex.type != GrLexemeType.Comma)
                    logError("Missing symbol", "Either a \',\' or a \')\' is expected");
            }
            else {
                //Is it a function type or a function declaration ?
                if(!asType) {
                    lex = get();
                    if(get().type != GrLexemeType.Identifier)
                        logError("Missing identifier", "Expected a name such as \'foo\'");
                    inputVariables ~= lex.svalue;
                    checkAdvance();
                }

                lex = get();
                if(lex.type == GrLexemeType.RightParenthesis)
                    break;
                else if(lex.type != GrLexemeType.Comma)
                    logError("Missing symbol", "Either a \',\' or a \')\' is expected");
            }
		}
		checkAdvance();

		return inSignature;
	}

    GrType[] parseOutSignature() {
		GrType[] outSignature;
        bool startLoop = true;
		for(;;) {
			GrLexeme lex = get();
            
            auto type = parseType(false);
            if(type.baseType != GrBaseType.VoidType)
                outSignature ~= type;

            lex = get();
            if(lex.type == GrLexemeType.LeftCurlyBrace || lex.type == GrLexemeType.Identifier)
                break;
            else if(lex.type != GrLexemeType.Comma)
                logError("Missing symbol", "Either a \',\' or a \'{\' is expected");
            checkAdvance();
		}
		return outSignature;
	}

	void parseMainDeclaration() {
		checkAdvance();
		beginFunction("main", []);
        
        openDeferrableSection();
		parseBlock();
		if(currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
            addKill();
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
	}

	void preParseMainDeclaration() {
		checkAdvance();
		preBeginFunction("main", [], [], false);
		skipBlock();
		preEndFunction();
	}

    void parseEventDeclaration() {
        checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
		dstring[] inputs;
		GrType[] signature = parseInSignature(inputs);
		beginFunction(name, signature, true);
        
        openDeferrableSection();
		parseBlock();
		if(currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
            addKill();
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
    }

    void preParseEventDeclaration() {
        checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
		dstring[] inputs;
		GrType[] signature = parseInSignature(inputs);
		preBeginFunction(name, signature, inputs, false, [], false, true);
		skipBlock();
		preEndFunction();
    }

	void parseTaskDeclaration() {
		checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
        const auto previousVariable = (name in globalVariables);
        if(previousVariable !is null)
            logError("Multiple declaration", "The identifier \'" ~ to!string(name) ~ "\' is already declared as a global variable");
		dstring[] inputs;
		GrType[] signature = parseInSignature(inputs);
		beginFunction(name, signature);

        openDeferrableSection();
		parseBlock();
		if(currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
            addKill();
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
	}

	void preParseTaskDeclaration() {
		checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
		dstring[] inputs;
		GrType[] signature = parseInSignature(inputs);
		preBeginFunction(name, signature, inputs, true);
		skipBlock();
		preEndFunction();
	}

	void parseFunctionDeclaration() {
		checkAdvance();
        dstring name;
        bool isConversion;
        if(get().type == GrLexemeType.As) {
            name = "@as";
            isConversion = true;
        }
        else {
            if(get().type != GrLexemeType.Identifier)
                logError("Missing identifier", "Expected a name such as \'foo\'");
            name = get().svalue;

            if(name == "operator") {
                checkAdvance();
                if(get().type >= GrLexemeType.Add && get().type <= GrLexemeType.Not) {
                    name = "@op_" ~ grGetPrettyLexemeType(get().type);
                }
                else
                    logError("Invalid Operator", "The specified operator must be valid");
            }
        }
        const auto previousVariable = (name in globalVariables);
        if(previousVariable !is null)
            logError("Multiple declaration", "The identifier \'" ~ to!string(name) ~ "\' is already declared as a global variable");
		dstring[] inputs;
		GrType[] signature = parseInSignature(inputs);

        if(isConversion) {
            if(signature.length != 1uL)
                logError("Invalid format", "A conversion function has to take only 1 parameter and be non-void");
            GrType[] outSignature = parseOutSignature();
            if(outSignature.length != 1uL)
                logError("Invalid format", "A conversion function has to take only 1 parameter and be non-void");

            signature ~= outSignature[0];
        }
        else
		    parseOutSignature();

		beginFunction(name, signature);
        openDeferrableSection();
		parseBlock();
        if(!currentFunction.outSignature.length) {
            if(currentFunction.instructions.length
                && currentFunction.instructions[$ - 1].opcode != GrOpcode.Return)
                addReturn();
        }
        else {
            if(currentFunction.instructions.length
                && currentFunction.instructions[$ - 1].opcode != GrOpcode.Return)
                logError("Missing return", "The function is missing a return at the end of the scope");
        }
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
	}

	void preParseFunctionDeclaration() {
		checkAdvance();
        dstring name;
        bool isConversion;
        if(get().type == GrLexemeType.As) {
            name = "@as";
            isConversion = true;
        }
        else {
            if(get().type != GrLexemeType.Identifier)
                logError("Missing identifier", "Expected a name such as \'foo\'");
            name = get().svalue;
            if(name == "operator") {
                checkAdvance();
                if(get().type >= GrLexemeType.Add && get().type <= GrLexemeType.Not) {
                    name = "@op_" ~ grGetPrettyLexemeType(get().type);
                }
                else
                    logError("Invalid Operator", "The specified operator must be valid");
            }
        }
		dstring[] inputs;
		GrType[] inSignature = parseInSignature(inputs);

		//Return Type.
        GrType[] outSignature;
        if(isConversion) {
            if(inSignature.length != 1uL)
                logError("Invalid format", "A conversion function has to take only 1 parameter");
            outSignature = parseOutSignature();
            if(!outSignature.length != 1uL)
                logError("Invalid format", "A conversion function can only have 1 return type");

            inSignature ~= outSignature[0];
        }
        else
            outSignature = parseOutSignature();

		preBeginFunction(name, inSignature, inputs, false, outSignature);
		skipBlock();
		preEndFunction();
	}

	GrType parseAnonymousFunction(bool isTask) {
		dstring[] inputs;
		GrType[] outSignature;
		GrType[] inSignature = parseInSignature(inputs);

		if(!isTask) {
			//Return Type.
            outSignature = parseOutSignature();
		}
		preBeginFunction("$anon"d, inSignature, inputs, isTask, outSignature, true);

        openDeferrableSection();
		parseBlock();

        if(isTask) {
            if(currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
		        addKill();
        }
        else {
            if(!outSignature.length) {
                if(currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode != GrOpcode.Return)
                    addReturn();
            }
            else {
                if(currentFunction.instructions.length
                    && currentFunction.instructions[$ - 1].opcode != GrOpcode.Return)
                    logError("Missing return", "The function is missing a return at the end of the scope");
            }
        }
            
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();

        GrType functionType = isTask ? GrBaseType.TaskType : GrBaseType.FunctionType;
        functionType.mangledType = grMangleNamedFunction("", inSignature);
        functionType.mangledReturnType = grMangleNamedFunction("", outSignature);


        return functionType;
	}

	void parseBlock() {
        bool isMultiline;
		if(get().type == GrLexemeType.LeftCurlyBrace) {
            isMultiline = true;
            if(!checkAdvance())
			    logError("Unexpected end of file");
        }
		openBlock();

		void parseStatement() {
            switch(get().type) with(GrLexemeType) {
            case Semicolon:
            case RightCurlyBrace:
                advance();
                break;
            case Defer:
                parseDeferStatement();
                break;
            case If:
            case Unless:
                parseIfStatement();
                break;
            case Switch:
                parseSwitchStatement();
                break;
            case While:
                parseWhileStatement();
                break;
            case Do:
                parseDoWhileStatement();
                break;
            case For:
                parseForStatement();
                break;
            case Loop:
                parseLoopStatement();
                break;
            case Raise:
                parseRaiseStatement();
                break;
            case Try:
                parseExceptionHandler();
                break;
            case Return:
                parseReturnStatement();
                break;
            case Kill:
                parseKill();
                break;
            case Yield:
                parseYield();
                break;
            case Continue:
                parseContinue();
                break;
            case Break:
                parseBreak();
                break;
            case VoidType: .. case AutoType:
                if(isDeclaration())
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            case Identifier:
                if(grIsTuple(get().svalue) || grIsStruct(get().svalue) || grIsUserType(get().svalue))
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            default:
                parseExpression();
                break;
            }
        }

        if(isMultiline) {
            while(!isEnd()) {
                if(get().type == GrLexemeType.RightCurlyBrace)
                    break;
                parseStatement();
            }
        }
        else {
            parseStatement();
        }

        if(isMultiline) {
            if(get().type != GrLexemeType.RightCurlyBrace)
                logError("Missing symbol", "A block should always end with \'}\'");
        }
		closeBlock();
		checkAdvance();
	}

    bool isDeclaration() {
        const auto tempPos = current;
        isTypeChecking = true;
        if(get().type == GrLexemeType.AutoType)
            checkAdvance();
        else
            parseType(false);
        isTypeChecking = false;
        bool isDecl;
        if(get().type == GrLexemeType.Identifier)
            isDecl = true;
        current = tempPos;
        return isDecl;
    }

	void skipBlock() {
		bool isMultiline;
		if(get().type == GrLexemeType.LeftCurlyBrace) {
            isMultiline = true;
            if(!checkAdvance())
			    logError("Unexpected end of file");
        }
		openBlock();

		void skipStatement() {
            switch(get().type) with(GrLexemeType) {
			case LeftCurlyBrace:
				skipBlock();
				break;
			default:
				checkAdvance();
				break;
			}
        }
		
		if(isMultiline) {
            while(!isEnd()) {
                if(get().type == GrLexemeType.RightCurlyBrace)
                    break;
                skipStatement();
            }
        }
        else {
            while(!isEnd()) {
                if(get().type == GrLexemeType.Semicolon)
                    break;
                skipStatement();
            }
        }

        if(isMultiline) {
            if(get().type != GrLexemeType.RightCurlyBrace)
                logError("Missing symbol", "A block should always end with \'}\'");
        }
		closeBlock();
		checkAdvance();
	}

    void parseKill() {
        if(currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
		    addKill();
        advance();                    
    }

    void parseYield() {
		addInstruction(GrOpcode.Yield, 0u);
        advance();                    
    }

    //Exception handling
    void parseRaiseStatement() {
        advance();
        GrType type = parseSubExpression(true, false, false, false);
        convertType(type, grString);
        addInstruction(GrOpcode.Raise);
        checkDeferStatement();
    }

    void parseExceptionHandler() {
        advance();

        const auto tryPosition = currentFunction.instructions.length;
        addInstruction(GrOpcode.Try);

        parseBlock();

        if(get().type != GrLexemeType.Catch)
            logError("Missing catch", "A try must be followed by a catch statement");
        advance();

        if(get().type != GrLexemeType.LeftParenthesis)
            logError("Missing (", "");
        advance();

        if(get().type != GrLexemeType.Identifier)
            logError("Missing identifier", "");
        GrVariable errVariable = registerLocalVariable(get().svalue, grString);

        advance();
        if(get().type != GrLexemeType.RightParenthesis)
            logError("Missing )", "");
        advance();

        const auto catchPosition = currentFunction.instructions.length;
        addInstruction(GrOpcode.Catch);

        addInstruction(GrOpcode.GlobalPop_String);
        addSetInstruction(errVariable, grString);

        parseBlock();

        const auto endPosition = currentFunction.instructions.length;


        setInstruction(GrOpcode.Try, cast(uint)tryPosition, cast(uint)(catchPosition - tryPosition), true);
        setInstruction(GrOpcode.Catch, cast(uint)catchPosition, cast(uint)(endPosition - catchPosition), true);
    }

    //Defer
    void openDeferrableSection() {
        auto deferrableSection = new GrDeferrableSection;
        deferrableSection.deferInitPositions = cast(uint)currentFunction.instructions.length;
        currentFunction.deferrableSections ~= deferrableSection;

        currentFunction.isDeferrableSectionLocked.length ++;
    }

    void closeDeferrableSection() {
        if(!currentFunction.deferrableSections.length)
            logError("Deferrable section error", "A deferrable section had a mismatch");

        foreach(deferBlock; currentFunction.deferrableSections[$ - 1].deferredBlocks) {
            currentFunction.registeredDeferBlocks ~= deferBlock;
        }

        currentFunction.deferrableSections.length --;
        currentFunction.isDeferrableSectionLocked.length --;
    }

    void parseDeferStatement() {
        if(currentFunction.isDeferrableSectionLocked[$ - 1])
            logError("Invalid instruction", "You cannot use a defer statement inside another defer");
        advance();

        //Register the position of the block for a late parsing.
        GrDeferBlock deferBlock = new GrDeferBlock;
        deferBlock.position = cast(uint)currentFunction.instructions.length;
        deferBlock.parsePosition = current;
        deferBlock.scopeLevel = scopeLevel;
        currentFunction.deferrableSections[$ - 1].deferredBlocks ~= deferBlock;

        addInstruction(GrOpcode.Defer);

        //Parse the deferred block at the end of the outer block.
        skipBlock();
    }
    
    void checkDeferStatement() {
        if(currentFunction.isDeferrableSectionLocked[$ - 1])
            logError("Invalid instruction", "You cannot use a flow-control statement in a defer");
    }

    void registerDeferBlocks() {
        const auto tempParsePosition = current;
        const auto startDeferPos = cast(uint)currentFunction.instructions.length;
        
        int tempScopeLevel = scopeLevel;
        while(currentFunction.registeredDeferBlocks.length) {
            GrDeferBlock deferBlock = currentFunction.registeredDeferBlocks[0];
            currentFunction.registeredDeferBlocks = currentFunction.registeredDeferBlocks[1 .. $];

            setInstruction(GrOpcode.Defer, deferBlock.position, cast(int)(currentFunction.instructions.length - deferBlock.position), true);
            current = deferBlock.parsePosition;
            scopeLevel = deferBlock.scopeLevel;

            currentFunction.isDeferrableSectionLocked[$ - 1] = true;
            parseBlock();
            currentFunction.isDeferrableSectionLocked[$ - 1] = false;

            addInstruction(GrOpcode.Unwind);
        }
        currentFunction.registeredDeferBlocks.length = 0;
        current = tempParsePosition;
        scopeLevel = tempScopeLevel;
    }

	//Break
	void openBreakableSection() {
		breaksJumps ~= [null];
	}

	void closeBreakableSection() {
		if(!breaksJumps.length)
			logError("Breakable section error", "A breakable section had a mismatch");

		uint[] breaks = breaksJumps[$ - 1];
		breaksJumps.length --;

		foreach(position; breaks)
			setInstruction(GrOpcode.Jump, position, cast(int)(currentFunction.instructions.length - position), true);
	}

	void parseBreak() {
		if(!breaksJumps.length)
			logError("Non breakable statement", "The break statement is not inside a breakable statement");

        checkDeferStatement();
		breaksJumps[$ - 1] ~= cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.Jump);
		advance();
	}

	//Continue
	void openContinuableSection() {
		continuesJumps ~= [null];
	}

	void closeContinuableSection() {
		if(!continuesJumps.length)
			logError("Continuable section error", "A continuable section had a mismatch");

		uint[] continues = continuesJumps[$ - 1];
		uint destination = continuesDestinations[$ - 1];
		continuesJumps.length --;
		continuesDestinations.length --;

		foreach(position; continues)
			setInstruction(GrOpcode.Jump, position, cast(int)(position - destination), true);
	}

	void setContinuableSectionDestination() {
		continuesDestinations ~= cast(uint)currentFunction.instructions.length;
	}

	void parseContinue() {
		if(!continuesJumps.length)
			logError("Non continuable statement", "The continue statement is not inside a continuable statement");

        checkDeferStatement();
		continuesJumps[$ - 1] ~= cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.Jump);
		advance();
	}

    void parseGlobalDeclaration() {
        //GrVariable type
        GrType type = GrBaseType.VoidType;
        bool isAuto;
        if(get().type == GrLexemeType.AutoType) {
            isAuto = true;
            checkAdvance();
        }
        else
            type = parseType();

        GrVariable[] lvalues;
        do {
            if(get().type == GrLexemeType.Comma)
                checkAdvance();
            //Identifier
            if(get().type != GrLexemeType.Identifier)
                logError("Missing identifier", "Expected a name such as \'foo\'");

            dstring identifier = get().svalue;

            //Registering
            GrVariable lvalue = registerGlobalVariable(identifier, type);
            lvalue.isAuto = isAuto;
            lvalues ~= lvalue;

            //A tuple does not need to be initialized.
            if(lvalue.type == GrBaseType.TupleType)
                lvalue.isInitialized = true;
            
            checkAdvance();
        }
        while(get().type == GrLexemeType.Comma);

		parseAssignList(lvalues);
    }

	//Type Identifier [= EXPRESSION] ;
	void parseLocalDeclaration() {
        //GrVariable type
        GrType type = GrBaseType.VoidType;
        bool isAuto;
        if(get().type == GrLexemeType.AutoType) {
            isAuto = true;
            checkAdvance();
        }
        else
            type = parseType();
        
        GrVariable[] lvalues;
        do {
            if(get().type == GrLexemeType.Comma)
                checkAdvance();
            //Identifier
            if(get().type != GrLexemeType.Identifier)
                logError("Missing identifier", "Expected a name such as \'foo\'");

            dstring identifier = get().svalue;

            //Registering
            GrVariable lvalue = registerLocalVariable(identifier, type);
            lvalue.isAuto = isAuto;
            lvalues ~= lvalue;

            //A composite type does not need to be initialized.
            if(lvalue.type == GrBaseType.TupleType || lvalue.type == GrBaseType.StructType)
                lvalue.isInitialized = true;
            
            checkAdvance();
        }
        while(get().type == GrLexemeType.Comma);

		parseAssignList(lvalues);
	}

    GrType parseFunctionReturnType() {
        GrType returnType = GrBaseType.VoidType;
        if(get().isType) {
            switch(get().type) with(GrLexemeType) {
            case IntType:
                returnType = GrType(GrBaseType.IntType);
                break;
            case FloatType:
                returnType = GrType(GrBaseType.FloatType);
                break;
            case BoolType:
                returnType = GrType(GrBaseType.BoolType);
                break;
            case StringType:
                returnType = GrType(GrBaseType.StringType);
                break;
            case ArrayType:
                returnType = GrType(GrBaseType.ArrayType);
                break;
            case VariantType:
                returnType = GrType(GrBaseType.VariantType);
                break;
            case FunctionType:
                GrType type = GrBaseType.FunctionType;
                dstring[] temp; 
                type.mangledType = grMangleNamedFunction("", parseInSignature(temp, true));
                returnType = type;
                break;
            case TaskType:
                GrType type = GrBaseType.TaskType;
                dstring[] temp;
                type.mangledType = grMangleNamedFunction("", parseInSignature(temp, true));
                returnType = type;
                break;
            default:
                logError("Invalid type", "A " ~ to!string(get().type) ~ " is not a valid return type");
            }
            checkAdvance();
        }

        return returnType;
    }

	void parseIfStatement() {
        bool isNegative = get().type == GrLexemeType.Unless;
		advance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		advance();
		parseSubExpression();
		advance();

		uint jumpPosition = cast(uint)currentFunction.instructions.length;
        //Jumps to if(0) for "if", if(!= 0) for "unless".
		addInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual);

		parseBlock(); //{ .. }

		//If(1){}, jumps out.
		uint[] exitJumps;
		exitJumps ~= cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.Jump);

		//Jumps to if(0) for "if", if(!= 0) for "unless".
		setInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual,
            jumpPosition,
            cast(int)(currentFunction.instructions.length - jumpPosition),
            true);

		bool isElseIf;
		do {
			isElseIf = false;
			if(get().type == GrLexemeType.Else) {
				checkAdvance();
				if(get().type == GrLexemeType.If || get().type == GrLexemeType.Unless) {
                    isNegative = get().type == GrLexemeType.Unless;
					isElseIf = true;
					checkAdvance();
					if(get().type != GrLexemeType.LeftParenthesis)
						logError("Missing symbol", "A condition should always start with \'(\'");
					checkAdvance();

					parseSubExpression();
                    advance();

					jumpPosition = cast(uint)currentFunction.instructions.length;
					//Jumps to if(0) for "if", if(!= 0) for "unless".
		            addInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual);

					parseBlock(); //{ .. }

					//If(1){}, jumps out.
					exitJumps ~= cast(uint)currentFunction.instructions.length;
					addInstruction(GrOpcode.Jump);

					//Jumps to if(0) for "if", if(!= 0) for "unless".
					setInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual,
                        jumpPosition,
                        cast(int)(currentFunction.instructions.length - jumpPosition),
                        true);
				}
				else
					parseBlock();
			}
		}
		while(isElseIf);

		foreach(uint position; exitJumps)
			setInstruction(GrOpcode.Jump, position, cast(int)(currentFunction.instructions.length - position), true);
	}

    void parseSwitchStatement() {
        advance();
        if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A switch statement should always start with \'(\'");

        advance();
		GrType switchType = parseSubExpression();
        GrVariable switchVar = registerSpecialVariable("switch"d ~ to!dstring(scopeLevel), switchType);
        addSetInstruction(switchVar);
        advance();

        /* A switch is breakable. */
		openBreakableSection();
        uint[] exitJumps;
        uint jumpPosition, defaultCasePosition;
        bool hasCase, hasDefaultCase;

        while(get().type == GrLexemeType.Case) {
            if(get(1).type == GrLexemeType.LeftParenthesis) {
                hasCase = true;
                advance();
                if(get().type != GrLexemeType.LeftParenthesis)
			        logError("Missing symbol", "A case statement should always start with \'(\'");
                advance();
                addGetInstruction(switchVar);
                GrType caseType = parseSubExpression();
                addBinaryOperator(GrLexemeType.Equal, switchType, caseType);
                advance();

                jumpPosition = cast(uint)currentFunction.instructions.length;
                //Jumps to if(0).
                addInstruction(GrOpcode.JumpEqual);

                parseBlock();

                exitJumps ~= cast(uint)currentFunction.instructions.length;
                addInstruction(GrOpcode.Jump);

                //Jumps to if(0).
                setInstruction(GrOpcode.JumpEqual,
                    jumpPosition,
                    cast(int)(currentFunction.instructions.length - jumpPosition),
                    true);
            }
            else if(get(1).type == GrLexemeType.LeftCurlyBrace) {
                if(hasDefaultCase)
                    logError("Multiple default cases", "There must be only one default case per switch statement");
                hasDefaultCase = true;

                advance();
                defaultCasePosition = current;

                skipBlock();
            }
            else {
                logError("Invalid case syntax", "It should be either case(VALUE) {} or case {}");
            }
        }

        if(hasDefaultCase) {
            uint tmp = current;
            current = defaultCasePosition;
            parseBlock();
            current = tmp;
        }

        /* A switch is breakable. */
		closeBreakableSection();

        foreach(uint position; exitJumps)
			setInstruction(GrOpcode.Jump, position, cast(int)(currentFunction.instructions.length - position), true);
    }

	void parseWhileStatement() {
		advance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		/* While is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		/* Continue jump. */
		setContinuableSectionDestination();

		uint conditionPosition,
			blockPosition = cast(uint)currentFunction.instructions.length;

		advance();
		parseSubExpression();

		advance();
		conditionPosition = cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.JumpEqual);

		parseBlock();

		addInstruction(GrOpcode.Jump, cast(int)(blockPosition - currentFunction.instructions.length), true);
		setInstruction(GrOpcode.JumpEqual, conditionPosition, cast(int)(currentFunction.instructions.length - conditionPosition), true);

		/* While is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

	void parseDoWhileStatement() {
		advance();

		/* While is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		uint blockPosition = cast(uint)currentFunction.instructions.length;

		parseBlock();
		if(get().type != GrLexemeType.While)
			logError("Missing while", "A do-while statement expects the keyword while after \'}\'");
		advance();

		/* Continue jump. */
		setContinuableSectionDestination();

		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		advance();
		parseSubExpression();
		advance();

		addInstruction(GrOpcode.JumpNotEqual, cast(int)(blockPosition - currentFunction.instructions.length), true);

		/* While is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

	void parseForStatement() {
		advance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		advance();
		GrLexeme identifier = get();
		if(identifier.type != GrLexemeType.Identifier)
			logError("Missing identifier", "For syntax: for(identifier, array) {}");
		GrVariable variable = getVariable(identifier.svalue);
		 
		advance();
		if(get().type != GrLexemeType.Comma)
			logError("Missing symbol", "Did you forget the \',\' ?");
		advance();

		/* Init */
		GrVariable iterator = registerSpecialVariable("iterator"d ~ to!dstring(scopeLevel), GrType(GrBaseType.IntType));
		GrVariable index = registerSpecialVariable("index"d ~ to!dstring(scopeLevel), GrType(GrBaseType.IntType));
		GrVariable array = registerSpecialVariable("array"d ~ to!dstring(scopeLevel), GrType(GrBaseType.ArrayType));
		
		//From length to 0
		GrType arrayType = parseSubExpression();
		addSetInstruction(array, GrType(GrBaseType.VoidType), true);
		addInstruction(GrOpcode.Length_Array);
		addInstruction(GrOpcode.SetupIterator);		
		addSetInstruction(iterator);

		//Set index to -1
		addIntConstant(-1);
		addSetInstruction(index);

		/* For is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		/* Continue jump. */
		setContinuableSectionDestination();


		advance();
		uint blockPosition = cast(uint)currentFunction.instructions.length;

		addGetInstruction(iterator, GrType(GrBaseType.IntType));
		addInstruction(GrOpcode.Decrement_Int);
		addSetInstruction(iterator);

		addGetInstruction(iterator, GrType(GrBaseType.IntType));
		uint jumpPosition = cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.JumpEqual);

		//Set Index
		addGetInstruction(array);
		addGetInstruction(index);
		addInstruction(GrOpcode.Increment_Int);
		addSetInstruction(index, GrType(GrBaseType.VoidType), true);
		addInstruction(GrOpcode.Index_Array);
		convertType(GrType(GrBaseType.VariantType), variable.type);
		addSetInstruction(variable);

		parseBlock();

		addInstruction(GrOpcode.Jump, cast(int)(blockPosition - currentFunction.instructions.length), true);
		setInstruction(GrOpcode.JumpEqual, jumpPosition, cast(int)(currentFunction.instructions.length - jumpPosition), true);

		/* For is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

	void parseLoopStatement() {
        bool isInfinite;
        GrVariable iterator;
        
		advance();
		if(get().type == GrLexemeType.LeftParenthesis) {
            advance();

            /* Init */
            iterator = registerSpecialVariable("iterator"d ~ to!dstring(scopeLevel), GrType(GrBaseType.IntType));
        
            //Init counter
            GrType type = parseSubExpression();
    		advance();

            convertType(type, GrType(GrBaseType.IntType));
            addInstruction(GrOpcode.SetupIterator);
            addSetInstruction(iterator);
        }
        else
            isInfinite = true;

		/* For is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		/* Continue jump. */
		setContinuableSectionDestination();


		uint blockPosition = cast(uint)currentFunction.instructions.length;
        uint jumpPosition;

        if(!isInfinite) {
            addGetInstruction(iterator, GrType(GrBaseType.IntType), false);
            addInstruction(GrOpcode.Decrement_Int);
            addSetInstruction(iterator);

            addGetInstruction(iterator, GrType(GrBaseType.IntType));
            jumpPosition = cast(uint)currentFunction.instructions.length;
            addInstruction(GrOpcode.JumpEqual);
        }

		parseBlock();

		addInstruction(GrOpcode.Jump, cast(int)(blockPosition - currentFunction.instructions.length), true);
		if(!isInfinite)
            setInstruction(GrOpcode.JumpEqual, jumpPosition, cast(int)(currentFunction.instructions.length - jumpPosition), true);

		/* For is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

	void parseReturnStatement() {
		checkAdvance();
        if(currentFunction.name == "main" || currentFunction.isTask) {
            if(currentFunction.instructions[$ - 1].opcode != GrOpcode.Kill)
                addKill();
        }
        else if(!currentFunction.outSignature.length) {
            if(currentFunction.instructions[$ - 1].opcode != GrOpcode.Return)
                addReturn();
        }
        else {
            auto types = parseExpressionList();
            
            addReturn();
            if(types.length != currentFunction.outSignature.length)
                logError("Invalid return type", "");
            for(int i; i < types.length; i ++) {
                if(types[i] != currentFunction.outSignature[i])
                    logError("Invalid return type",
                        "The returned type \'"
                        ~ to!string(types[i])
                        ~ "\' does not match the function definition \'"
                        ~ to!string(currentFunction.outSignature[0])
                        ~ "\'");
            }
        }
	}

    void addReturn() {
        checkDeferStatement();
        addInstruction(GrOpcode.Return);
    }

    void addKill() {
        checkDeferStatement();
        addInstruction(GrOpcode.Kill);
    }

    uint getLeftOperatorPriority(GrLexemeType type) {
		switch(type) with(GrLexemeType) {
        case Assign: .. case PowerAssign:
            return 6;
        case Or:
            return 1;
        case Xor:
            return 2;
        case And:
            return 3;
        case Equal: .. case NotEqual:
            return 14;
        case GreaterOrEqual: .. case Lesser:
            return 15;
        case Add: .. case Substract:
            return 16;
        case Multiply: .. case Remainder:
            return 17;
        case Power:
            return 18;
        case Not:
        case Plus:
        case Minus:
        case Increment:
        case Decrement:
            return 19;
        default:
            logError("Unknown priority", "The operator is not listed in the operator priority table");
            return 0;
		}
	}

	uint getRightOperatorPriority(GrLexemeType type) {
		switch(type) with(GrLexemeType) {
        case Assign: .. case PowerAssign:
            return 20;
        case Or:
            return 1;
        case Xor:
            return 2;
        case And:
            return 3;
        case Equal: .. case NotEqual:
            return 4;
        case GreaterOrEqual: .. case Lesser:
            return 5;
        case Add: .. case Substract:
            return 16;
        case Multiply: .. case Remainder:
            return 17;
        case Power:
            return 18;
        case Not:
        case Plus:
        case Minus:
        case Increment:
        case Decrement:
            return 19;
        default:
            logError("Unknown priority", "The operator is not listed in the operator priority table");
            return 0;
		}
	}

	GrType convertType(GrType src, GrType dst, bool noFail = false, bool isExplicit = false) {
        if(src.baseType == dst.baseType) {
            switch(src.baseType) with(GrBaseType) {
            case FunctionType:
                if(src.mangledType == dst.mangledType && src.mangledReturnType == dst.mangledReturnType)
                    return dst;
                break;
            case TaskType:
                if(src.mangledType == dst.mangledType && src.mangledReturnType == dst.mangledReturnType)
                    return dst;
                break;
            case BoolType:
            case IntType:
            case FloatType:
            case StringType:
            case VariantType:
            case ArrayType:
                return dst;
            case TupleType:
            case StructType:
            case UserType:
                if(dst.mangledType == src.mangledType)
                    return dst;
                break;
            default:
                break;
            }
        }

        if(src.baseType == GrBaseType.InternalTupleType || dst.baseType == GrBaseType.InternalTupleType)
            logError("Convertion error", "Cannot convert multiple values from an expression list");
		
        //User-defined conversions.
        if(addCustomConversion(src, dst, isExplicit) == dst)
            return dst;
        
        if(!noFail)
		    logError("Incompatible types", "Cannot convert \'"
                ~ grGetPrettyType(src) ~ "\' to \'" ~ grGetPrettyType(dst) ~ "\'");
		return GrType(GrBaseType.VoidType);	
	}

    GrType addCustomConversion(GrType leftType, GrType rightType, bool isExplicit) {
        GrType resultType = GrBaseType.VoidType;

        //As opposed to other functions, we need the return type (rightType) to be part of the signature.
        dstring mangledName = grMangleNamedFunction("@as", [leftType, rightType]);

        //Special conversions
        if(leftType != rightType) {
            if(rightType.baseType == GrBaseType.VariantType) {
                switch(leftType.baseType) with(GrBaseType) {
                case FunctionType:
                case TaskType:
                    //We can't know in advance what'll be the signature of the anonymous function we want to convert.
                    //So we add the mangling as a runtime meta value.
                    addMetaConstant(grMangleVariant(leftType));
                    //Then, we delete the mangling, and the cast primitive will do the same.
                    GrType tempType = leftType;
                    tempType.mangledType = grMangleNamedFunction("", []);
                    tempType.mangledReturnType = "";
                    mangledName = grMangleNamedFunction("@as", [tempType, rightType]);
                    break;
                default:
                    break;
                }
            }
            else if(leftType.baseType == GrBaseType.VariantType) {
                switch(rightType.baseType) with(GrBaseType) {
                case FunctionType:
                case TaskType:
                    //We can't know in advance what'll be the signature of the anonymous function we want to convert.
                    //So we add the mangling as a runtime meta value.
                    addMetaConstant(grMangleVariant(rightType));
                    //Then, we delete the mangling, and the cast primitive will do the same.
                    GrType tempType = rightType;
                    tempType.mangledType = grMangleNamedFunction("", []);
                    tempType.mangledReturnType = "";
                    mangledName = grMangleNamedFunction("@as", [leftType, tempType]);
                    break;
                default:
                    break;
                }
            }
        }
        
        //GrPrimitive check
        if(grIsPrimitiveDeclared(mangledName)) {
            GrPrimitive primitive = grGetPrimitive(mangledName);
            //Some implicit conversions are disabled.
            //ex: float -> int because we might lose information.
            if(primitive.isExplicit && !isExplicit)
                return resultType;
            addInstruction(GrOpcode.PrimitiveCall, primitive.index);
            if(primitive.outSignature.length != 1uL)
                logError("Return signature error", "An operator can only have one return value");
            resultType = rightType;
        }

        //GrFunction check
        if(resultType.baseType == GrBaseType.VoidType) {
    		const auto func = (mangledName in functions);
            if(func !is null) {
                auto outSignature = addFunctionCall(mangledName);
                if(outSignature.length != 1uL)
                    logError("Return signature error", "An operator can only have one return value");
                resultType = rightType;
            }
        }

        return resultType;     
    }

    void parseArrayBuilder() {
        if(get().type != GrLexemeType.LeftBracket)
            logError("Missing [", "Missing [");
        advance();

        int arraySize;
        while(get().type != GrLexemeType.RightBracket) {
            convertType(parseSubExpression(false, true, true, false), grVariant);
            arraySize ++;

            if(get().type == GrLexemeType.RightBracket)
                break;
            if(get().type != GrLexemeType.Comma)
                logError("Missing comma or ]", "bottom text");
            checkAdvance();
        }

        addInstruction(GrOpcode.Build_Array, arraySize);
        advance();
    }

    void parseArrayIndex(GrType arrayType) {
        if(get().type != GrLexemeType.LeftBracket)
            logError("Missing [", "Missing [");
        advance();

        for(;;) {
            if(get().type == GrLexemeType.Comma)
                logError("Missing value", "bottom text");
            auto index = parseSubExpression(false, true, true, false);
            if(index.baseType == GrBaseType.VoidType)
                logError("Syntax Error", "right there");
            convertType(index, grInt);

            if(get().type == GrLexemeType.RightBracket) {
                switch(arrayType.baseType) with(GrBaseType) {
                case ArrayType:
                    addInstruction(GrOpcode.Index_Array);
                    break;
                case VariantType:
                    addInstruction(GrOpcode.Index_Variant);
                    break;
                default:
                    logError("Invalid array type", "Can only index array or variant value");
                }
                break;
            }
            if(get().type != GrLexemeType.Comma)
                logError("Missing comma or ]", "bottom text");
            checkAdvance();
            if(get().type == GrLexemeType.RightBracket)
                logError("Missing comma or ]", "bottom text");

            switch(arrayType.baseType) with(GrBaseType) {
            case ArrayType:
                addInstruction(GrOpcode.Index_Array);
                break;
            case VariantType:
                addInstruction(GrOpcode.Index_Variant);
                break;
            default:
                logError("Invalid array type", "Can only index array or variant value");
            }
            arrayType = grVariant;
        }

        advance();
    }

    GrType parseTupleField(GrType type) {
        dstring fieldName;
        GrType fieldType = GrBaseType.VoidType;

        advance();
        if(type.baseType != GrBaseType.TupleType)
            logError("Invalid type", "Cannot access struct field");
        if(get().type != GrLexemeType.Identifier)
            logError("Missing struct field", "Missing struct field");
        fieldName = get().svalue;
        advance();
        auto tuple = grGetTuple(type.mangledType);
        const auto nbFields = tuple.fields.length;
        for(int i = 1; i <= tuple.fields.length; i ++) {
            if(fieldName == tuple.fields[nbFields - i]) {
                fieldType = tuple.signature[nbFields - i];
                addGlobalPush(fieldType, 1u);
            }
            else
                shiftStackPosition(tuple.signature[nbFields - i], -1);
        }
        addGlobalPop(fieldType);
        return fieldType;
    }

    GrType parseConversionOperator(GrType[] typeStack) {
        if(!typeStack.length)
            logError("Conversion Error", "You can only convert a value");
        advance();
        auto asType = parseType();
        convertType(typeStack[$ - 1], asType, false, true);
        typeStack[$ - 1] = asType;
        return asType;
    }

    GrVariable parseLValue() {
        if(get().type != GrLexemeType.Identifier)
            logError("Missing lvalue", "Missing lvalue");

        dstring identifierName = get().svalue;

        checkAdvance();

        if(get().type == GrLexemeType.Colon) {
			auto structVar = getVariable(identifierName);
            if(structVar is null || structVar.type.baseType != GrBaseType.TupleType)
                logError("Invalid symbol", "You can only access a field from a struct");
            else {
                do {
                    checkAdvance();
                    if(get().type != GrLexemeType.Identifier)
                        logError("Missing identifier", "A struct field must have a name");
                    identifierName ~= ":" ~ get().svalue;
                    checkAdvance();
                }
                while(get().type == GrLexemeType.Colon);
            }
        }

        auto lvalue = (identifierName in currentFunction.localVariables);
        if(lvalue is null)
            lvalue = (identifierName in globalVariables);

        if(lvalue is null)
            logError("Missing lvalue", "Missing lvalue");
        
        return *lvalue;
    }

	void parseExpression() {
        bool isAssignmentList;
        if(get().type == GrLexemeType.Identifier) {
            const auto tempPos = current;
            checkAdvance();
            while(get().type == GrLexemeType.Identifier
                || get().type == GrLexemeType.Colon) {
                checkAdvance();
            }
            if(get().type == GrLexemeType.Comma)
                isAssignmentList = true;
            current = tempPos;
        }

        if(isAssignmentList) {
            //Get list of lvalues
            GrVariable[] lvalues;
            do {
                if(lvalues.length)
                    checkAdvance();
                //Identifier
                if(get().type != GrLexemeType.Identifier)
                    logError("Missing identifier", "Expected a name such as \'foo\'");

                lvalues ~= parseLValue();
            }
            while(get().type == GrLexemeType.Comma);

            parseAssignList(lvalues);
        }
        else {
            parseSubExpression(true, false, false, false, true);
        }
	}

    GrType[] parseExpressionList() {
        GrType[] expressionTypes;
        for(;;) {
            GrType type = parseSubExpression(true, false, true, false);
            if(type.baseType == GrBaseType.InternalTupleType) {
                auto types = grUnpackTuple(type);
                if(!types.length)
                    logError("Empty return value", "Cannot return a void value");
                else {
                    foreach(subType; types)
                        expressionTypes ~= subType;
                }
            }
            else
                expressionTypes ~= type;
            if(get().type != GrLexemeType.Comma)
                break;
            checkAdvance();
        }
        if(get().type != GrLexemeType.Semicolon)
            logError("Missing semicolon", "An expression list must be finished with a ;");
        checkAdvance();
        return expressionTypes;
    }

    void parseAssignList(GrVariable[] lvalues) {
        switch(get().type) with(GrLexemeType) {
        case Assign:
            advance();
            GrType[] expressionTypes = parseExpressionList();
            
            if(expressionTypes.length > lvalues.length)
                logError("Exceeding number of expressions", "Cannot assign more values than identifiers");

            int variableIndex = to!int(lvalues.length) - 1;
            int expressionIndex = to!int(expressionTypes.length) - 1;
            bool passThrough;
            GrVariable[] skippedLvalues;
            while(variableIndex > expressionIndex) {
                addSetInstruction(lvalues[variableIndex], expressionTypes[expressionIndex], true);
                variableIndex --;
                passThrough = true;
            }
            if(passThrough) {
                if(expressionTypes[expressionIndex].baseType == GrBaseType.VoidType) {
                    skippedLvalues ~= lvalues[variableIndex];
                }
                else {
                    addSetInstruction(lvalues[variableIndex], lvalues[variableIndex + 1].type, false);
                }
                variableIndex --;
                expressionIndex --;
            }
            while(variableIndex >= 0) {
                if(expressionTypes[expressionIndex].baseType == GrBaseType.VoidType) {
                    skippedLvalues ~= lvalues[variableIndex];
                }
                else {
                    while(skippedLvalues.length) {
                        addSetInstruction(skippedLvalues[$ - 1], expressionTypes[expressionIndex], true);
                        skippedLvalues.length --;
                    }
                    addSetInstruction(lvalues[variableIndex], expressionTypes[expressionIndex], false);
                }
                variableIndex --;
                expressionIndex --;
            }
            if(skippedLvalues.length)
                logError("Assignment List", "First element cannot be empty");
            break;
        case Semicolon:
            advance();
            break;
        default:
            logError("Invalid symbol", "A declaration must either be terminated by a ; or assigned with =");
        }
    }

    void shiftStackPosition(GrType type, short count) {
        struct TypeCounter {
            int iCount, fCount, sCount, nCount, dCount, oCount, uCount;
        }
        TypeCounter counter;
        void countSubTypes(GrType type, ref TypeCounter counter) {
            final switch(type.baseType) with(GrBaseType) {
            case IntType:
            case BoolType:
            case FunctionType:
            case TaskType:
                counter.iCount ++;
                break;
            case FloatType:
                counter.fCount ++;
                break;
            case StringType:
                counter.sCount ++;
                break;
            case VariantType:
                counter.dCount ++;
                break;
            case StructType:
            case ArrayType:
            case UserType:
                counter.uCount ++;
                break;
            case TupleType:
                auto tuple = grGetTuple(type.mangledType);
                const auto nbFields = tuple.fields.length;
                for(int i = 1; i <= tuple.fields.length; i ++) {
                    countSubTypes(tuple.signature[nbFields - i], counter);
                }
                break;
            case VoidType:
                throw new Exception("Cannot change the stack for a struct type");
            case InternalTupleType:
                throw new Exception("Tuples should not exist here.");
            }
        }
        countSubTypes(type, counter);

        if(counter.iCount)
            addInstruction(GrOpcode.ShiftStack_Int, counter.iCount * count, true);
        if(counter.fCount)
            addInstruction(GrOpcode.ShiftStack_Float, counter.fCount * count, true);
        if(counter.sCount)
            addInstruction(GrOpcode.ShiftStack_String, counter.sCount * count, true);
        if(counter.dCount)
            addInstruction(GrOpcode.ShiftStack_Variant, counter.dCount * count, true);
        if(counter.uCount)
            addInstruction(GrOpcode.ShiftStack_UserData, counter.uCount * count, true);
    }

    bool requireLValue(GrLexemeType operatorType) {
        switch(operatorType) with(GrLexemeType) {
        case Period:
        case Increment:
        case Decrement:
        case Assign: .. case PowerAssign:
            return true;
        default:
            return false;
        }
    }

    GrType parseFunctionPointer(GrType currentType) {
        checkAdvance();
        if(get().type == GrLexemeType.LeftParenthesis) {
            checkAdvance();
            GrType refType = parseType();
            if(get().type != GrLexemeType.RightParenthesis)
                logError("Missing symbol", "Expected a \')\' after the type");
            checkAdvance();
            if(currentType.baseType == GrBaseType.VoidType)
                currentType = refType;
            else
                currentType = convertType(refType, currentType);
        }
        if(get().type != GrLexemeType.Identifier)
            logError("GrFunction name expected", "The name of the func or task is required after \'&\'");
        if(currentType.baseType != GrBaseType.FunctionType && currentType.baseType != GrBaseType.TaskType)
            logError("GrFunction ref error", "Cannot infer the type of \'" ~ to!string(get().svalue) ~ "\'");

        GrType funcType = addFunctionAddress(get().svalue ~ currentType.mangledType);
        convertType(funcType, currentType);
        checkAdvance();
        return currentType;
    }
    
	GrType parseSubExpression(bool useSemicolon = false, bool useBracket = false, bool useComma = false, bool useParenthesis = true, bool mustCleanValue = false) {
		GrVariable[] lvalues;
		GrLexemeType[] operatorsStack;
		GrType[] typeStack;
		GrType currentType = GrType(GrBaseType.VoidType), lastType = GrType(GrBaseType.VoidType);
		bool hasValue = false, hadValue = false,
        hasLValue = false, hadLValue = false,
        hasReference = false, hadReference = false,
		isRightUnaryOperator = true, isEndOfExpression = false;

		do {
			if(hasValue && currentType != lastType && lastType != GrType(GrBaseType.VoidType)) {
				lastType = currentType;//convertType(currentType, lastType);
				currentType = lastType;
			}
            else
                lastType = currentType;

			isRightUnaryOperator = false;
			hadValue = hasValue;
			hasValue = false;

			hadLValue = hasLValue;
			hasLValue = false;

            hadReference = hasReference;
            hasReference = false;

			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
			case Semicolon:
				if(useSemicolon)
					isEndOfExpression = true;
                else
					logError("Unexpected symbol", "A \';\' cannot exist inside this expression");
				break;
			case Comma:
				if(useComma)
					isEndOfExpression = true;
				else
					logError("Unexpected symbol", "A \',\' cannot exist inside this expression");
				break;
			case RightParenthesis:
				if(useParenthesis)
					isEndOfExpression = true;
				else
					logError("Unexpected symbol", "A \')\' cannot exist inside this expression");
				break;
            case RightBracket:
				if(useBracket)
					isEndOfExpression = true;
				else
					logError("Unexpected symbol", "A \']\' cannot exist inside this expression");
				break;
			case LeftParenthesis:
                if(hadValue) {
                    currentType = parseAnonymousCall(typeStack[$ - 1]);
                    //Unpack function value for 1 or less return values
                    //Multiples values are left as a tuple for parseExpressionList()
                    if(currentType.baseType == GrBaseType.InternalTupleType) {
                        auto types = grUnpackTuple(currentType);
                        if(!types.length)
                            currentType = grVoid;
                        else if(types.length == 1uL)
                            currentType = types[0];
                    }
                    if(currentType.baseType == GrBaseType.VoidType) {
                        typeStack.length --;
                    }
                    else {
                        hadValue = false;
                        hasValue = true;
                        typeStack[$ - 1] = currentType;
                    }
                }
                else {
                    advance();
                    currentType = parseSubExpression();
                    advance();
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            case LeftBracket:
                //Index
                if(hadValue) {
                    hadValue = false;
                    parseArrayIndex(lastType);
                    currentType = GrType(GrBaseType.VariantType);
                    lastType = GrType(GrBaseType.VariantType);
                    hasReference = true;
                    //Check if there is an assignement or not, discard if it's only a rvalue
                    const auto nextLexeme = get();
                    if(requireLValue(nextLexeme.type)) {
                        hasLValue = true;
                        lvalues ~= null;
                    }
                    typeStack[$ - 1] = currentType;
                }
                //Build new array
                else {
                    currentType = GrType(GrBaseType.ArrayType);
                    parseArrayBuilder();
                    typeStack ~= currentType;
                }
                hasValue = true;
                break;
            case Colon:
                currentType = parseTupleField(currentType);
                lastType = currentType;
                hadValue = false;
                hasValue = true;
                typeStack[$ - 1] = currentType;
                break;
			case Integer:
				currentType = GrType(GrBaseType.IntType);
				addIntConstant(lex.ivalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case Float:
				currentType = GrType(GrBaseType.FloatType);
				addFloatConstant(lex.fvalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case Boolean:
				currentType = GrType(GrBaseType.BoolType);
				addBoolConstant(lex.bvalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case String:
				currentType = GrType(GrBaseType.StringType);
				addStringConstant(lex.svalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
            case New:
                checkAdvance();
                if(get().type != GrLexemeType.Identifier)
                    logError("Missing type", "Missing a type name to instanciate");
                currentType = grGetStructType(get().svalue);
                hasValue = true;
                typeStack ~= currentType;
                GrStruct structure = grGetStruct(get().svalue);
                addInstruction(GrOpcode.New, cast(int)structure.signature.length);
                checkAdvance();
                break;
            case Copy:
                switch(currentType.baseType) with(GrBaseType) {
                case ArrayType:
                    addInstruction(GrOpcode.Copy_Array);
                    break;
                case VariantType:
                    addInstruction(GrOpcode.Copy_Variant);
                    break;
                default:
                    logError("Invalid copy", "Cannot apply copy operator to that");
                }
                hasValue = true;
                hadValue = false;
                checkAdvance();
                break;
            case Period:
                if(currentType.baseType != GrBaseType.StructType)
                    logError("Field operator error", "It's not a struct type");
                checkAdvance();
                if(get().type != GrLexemeType.Identifier) //TODO: change to handle tuples
                    logError("Missing identifier", "Missing field name after the \'.\'");
                const dstring identifier = get().svalue;
                checkAdvance();
                GrStruct structure = grGetStruct(currentType.mangledType);
                const auto nbFields = structure.signature.length;
                bool hasField;
                for(int i; i < nbFields; i ++) {
                    if(identifier == structure.fields[i]) {
                        hasField = true;
                        currentType = structure.signature[i];
                        currentType.isField = true;
                        GrVariable fieldLValue = new GrVariable;
                        fieldLValue.isInitialized = true;
                        fieldLValue.isField = true;
                        fieldLValue.type = currentType;
                        fieldLValue.index = i;

                        lvalues[$ - 1] = fieldLValue;
                        typeStack[$ - 1] = currentType;

                        hasValue = true;
                        hadValue = false;
					    hasLValue = true;
                        hadLValue = false;
                        addInstruction(GrOpcode.GetField, fieldLValue.index);

                        void addLoadFieldInstruction(GrType type, bool asCopy) {
                            int stackShift = asCopy ? 0 : -1;

                            switch(type.baseType) with(GrBaseType) {
                            case BoolType:
                            case IntType:
                            case FunctionType:
                            case TaskType:
                                addInstruction(GrOpcode.FieldLoad_Int, stackShift, true);
                                break;
                            default:
                                logError("Not implemented", "parseSubExpression:Period");
                                break;
                            }
                        }

                        switch(get().type) with(GrLexemeType) {
                        case Period:
                        case Increment:
                        case Decrement:
                        case Assign:
                            break;
                        case AddAssign: .. case PowerAssign:
                            addLoadFieldInstruction(currentType, true);
                            break;
                        default:
                            addLoadFieldInstruction(currentType, false);
                            break;
                        }
                        break;
                    }
                }
                if(!hasField)
                    logError("Field not found", "Can't find it");
                break;
            case Pointer:
                currentType = parseFunctionPointer(currentType);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case As:
                if(!hadValue)
                    logError("","");
                currentType = parseConversionOperator(typeStack);
                hasValue = true;
                hadValue = false;
                break;
			case FunctionType:
				currentType = parseAnonymousFunction(false);
                typeStack ~= currentType;
				hasValue = true;
				break;
			case TaskType:
				currentType = parseAnonymousFunction(true);
                typeStack ~= currentType;
				hasValue = true;
				break;
			case Assign: .. case PowerAssign:
				if(!hadLValue)
					logError("Expression invalid", "Missing lvalue in expression");
				hadLValue = false;
				goto case Multiply;
			case Add:
				if(!hadValue)
					lex.type = GrLexemeType.Plus;
				goto case Multiply;
			case Substract:
				if(!hadValue)
					lex.type = GrLexemeType.Minus;
				goto case Multiply;
			case Increment: .. case Decrement:
				isRightUnaryOperator = true;
				goto case Multiply;
			case Multiply: .. case Not:
				if(!hadValue && lex.type != GrLexemeType.Plus && lex.type != GrLexemeType.Minus && lex.type != GrLexemeType.Not)
					logError("Expected value", "A value is missing");

				while(operatorsStack.length && getLeftOperatorPriority(operatorsStack[$ - 1]) > getRightOperatorPriority(lex.type)) {
					GrLexemeType operator = operatorsStack[$ - 1];
	
					switch(operator) with(GrLexemeType) {
					case Assign:
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					case AddAssign: .. case PowerAssign:
						currentType = addOperator(operator - (GrLexemeType.AddAssign - GrLexemeType.Add), typeStack);
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					case Increment: .. case Decrement:
						currentType = addOperator(operator, typeStack);
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					default:
						currentType = addOperator(operator, typeStack);
						break;
					}

					operatorsStack.length --;
				}

				operatorsStack ~= lex.type;
				if(hadValue && isRightUnaryOperator) {
					hasValue = true;
					hadValue = false;
				}
				else
					hasValue = false;
				checkAdvance();
				break;
			case Identifier:
				GrVariable lvalue;
				currentType = parseIdentifier(lvalue, lastType);
                //Unpack function value for 1 or less return values
                //Multiples values are left as a tuple for parseExpressionList()
                if(currentType.baseType == GrBaseType.InternalTupleType) {
                    auto types = grUnpackTuple(currentType);
                    if(!types.length)
                        currentType = grVoid;
                    else if(types.length == 1uL)
                        currentType = types[0];
                }

                //Check if there is an assignement or not, discard if it's only a rvalue
                const auto nextLexeme = get();
				if(lvalue !is null && requireLValue(nextLexeme.type)) {
					hasLValue = true;
					lvalues ~= lvalue;

                    if(lvalue.isAuto)
                        hasValue = true;
				}

                if(!hasLValue && nextLexeme.type == GrLexemeType.LeftBracket)
                    hasReference = true;

				if(currentType != GrType(GrBaseType.VoidType)) {
					hasValue = true;
                    typeStack ~= currentType;
                }
				break;
			default:
				logError("Unexpected symbol", "Invalid \'" ~ to!string(lex.type) ~ "\' symbol in the expression");
			}

			if(hasValue && hadValue)
                logError("Missing symbol", "The expression is not terminated by a \';\'");
		}
		while(!isEndOfExpression);

		if(operatorsStack.length) {
			if(!hadValue) {
				if(!isRightUnaryOperator)
					logError("Expected value", "A value is missing");
				else
					logError("Expected value", "A value is missing");
			}
		}

		while(operatorsStack.length) {
			GrLexemeType operator = operatorsStack[$ - 1];
	
			switch(operator) with(GrLexemeType) {
			case Assign:
				addSetInstruction(lvalues[$ - 1], currentType, operatorsStack.length > 1uL);
				lvalues.length --;

                if(operatorsStack.length <= 1uL)
                    hadValue = false;
				break;
			case AddAssign: .. case PowerAssign:
				currentType = addOperator(operator - (GrLexemeType.AddAssign - GrLexemeType.Add), typeStack);
				addSetInstruction(lvalues[$ - 1], currentType, operatorsStack.length > 1uL);			
				lvalues.length --;

                if(operatorsStack.length <= 1uL)
                    hadValue = false;
				break;
			case Increment: .. case Decrement:
				currentType = addOperator(operator, typeStack);
				addSetInstruction(lvalues[$ - 1], currentType, operatorsStack.length > 1uL);
				lvalues.length --;

                if(operatorsStack.length <= 1uL)
                    hadValue = false;
				break;
			default:
				currentType = addOperator(operator, typeStack);
				break;
			}

			operatorsStack.length --;
		}
        
        if(mustCleanValue && hadValue && currentType.baseType != GrBaseType.VoidType)
            shiftStackPosition(currentType, -1);
        
        return currentType;
	}

    GrType parseAnonymousCall(GrType type) {
        GrVariable functionId;
        if(type.baseType == GrBaseType.FunctionType) {
            functionId = registerSpecialVariable("anon", GrType(GrBaseType.IntType));
            addSetInstruction(functionId, GrType(GrBaseType.IntType));
        }

        checkAdvance();
        //Signature parsing with type conversion
		GrType[] signature;
        GrType[] anonSignature = grUnmangleSignature(type.mangledType);
        int i;
        if(get().type != GrLexemeType.RightParenthesis) {
            for(;;) {
                if(type.baseType != GrBaseType.VariantType && i >= anonSignature.length)
                    logError("Invalid anonymous call", "The number of parameters does not match");
                GrType subType = parseSubExpression(false, false, true, true);
                if(type.baseType == GrBaseType.VariantType)
                    signature ~= subType;
                else
                    signature ~= convertType(subType, anonSignature[i]);
                if(get().type == GrLexemeType.RightParenthesis)
                    break;
                advance();
                i ++;
            }
        }
        checkAdvance();

        //Push the values on the global stack for task spawning.
        if(type.baseType == GrBaseType.TaskType)
            addGlobalPush(signature);

        //Anonymous call.
        GrType retTypes = grPackTuple(grUnmangleSignature(type.mangledReturnType));

        if(type.baseType == GrBaseType.FunctionType) {
		    addGetInstruction(functionId, GrType(GrBaseType.IntType));
        }

        if(type.baseType == GrBaseType.FunctionType)
            addInstruction(GrOpcode.AnonymousCall, 0u);
        else if(type.baseType == GrBaseType.TaskType)
            addInstruction(GrOpcode.AnonymousTask, 0u);
        else if(type.baseType == GrBaseType.VariantType) {
            dstring meta = grMangleFunction(signature);
            addInstruction(GrOpcode.VariantCall, registerStringConstant(meta));
        }
        else
            logError("Invalid anonymous type", "debug");
        return retTypes;
    }

	//Parse an identifier or function call and return the deduced return type and lvalue.
	GrType parseIdentifier(ref GrVariable variable, GrType expectedType) {
        if(expectedType.isField)
            writeln("ISFIELD");//TODO
		GrType returnType = GrBaseType.VoidType;
		GrLexeme identifier = get();		
		bool isFunctionCall = false;
        dstring identifierName = identifier.svalue;

		advance();

        if(get().type == GrLexemeType.Colon) {
			auto structVar = getVariable(identifier.svalue);
            if(structVar is null || structVar.type.baseType != GrBaseType.TupleType)
                logError("Invalid symbol", "You can only access a field from a struct");
            else {
                do {
                    checkAdvance();
                    if(get().type != GrLexemeType.Identifier)
                        logError("Missing identifier", "A struct field must have a name");
                    identifierName ~= ":" ~ get().svalue;
                    checkAdvance();
                }
                while(get().type == GrLexemeType.Colon);
            }
        }

		if(get().type == GrLexemeType.LeftParenthesis)
			isFunctionCall = true;

		if(isFunctionCall) {
			GrType[] signature;
			advance();

			auto var = (identifierName in currentFunction.localVariables);
            if(var is null)
                var = (identifierName in globalVariables);
			if(var !is null) {
                //Signature parsing with type conversion
                GrType[] anonSignature = grUnmangleSignature(var.type.mangledType);
                int i;
                if(get().type != GrLexemeType.RightParenthesis) {
                    for(;;) {
                        if(var.type.baseType != GrBaseType.VariantType && i >= anonSignature.length)
                            logError("Invalid anonymous call", "The number of parameters does not match");
                        GrType subType = parseSubExpression(false, false, true, true);
                        if(subType.baseType == GrBaseType.InternalTupleType) {
                            auto types = grUnpackTuple(subType);
                            if(types.length) {
                                if(var.type.baseType == GrBaseType.VariantType) {
                                    for(int y; y < types.length; y ++, i ++) {
                                        if(i >= anonSignature.length)
                                            logError("Invalid anonymous call", "The number of parameters does not match");
                                        signature ~= convertType(types[y], anonSignature[i]);
                                    }
                                }
                                else {
                                    for(int y; y < types.length; y ++, i ++) {
                                        signature ~= types[y];
                                    }
                                }
                            }
                            else
                                logError("Cannot use a void function", "Cannot use a void function as a parameter");
                        }
                        else {
                            if(var.type.baseType == GrBaseType.VariantType)
                                signature ~= subType;
                            else
                                signature ~= convertType(subType, anonSignature[i]);
                            i ++;
                        }
                        if(get().type == GrLexemeType.RightParenthesis) {
                            if(var.type.baseType != GrBaseType.VariantType && signature.length != anonSignature.length)
                                logError("Invalid anonymous call", "The number of parameters does not match");
                            break;
                        }
                        advance();
                    }
                }
                else if(var.type.baseType != GrBaseType.VariantType && anonSignature.length)
                     logError("Invalid anonymous call", "The number of parameters does not match");
                checkAdvance();

                //Push the values on the global stack for task spawning.
                if(var.type.baseType == GrBaseType.TaskType)
                    addGlobalPush(signature);

				//Anonymous call.
				bool hasAnonFunc = false;
				addGetInstruction(*var);
                
				returnType = grPackTuple(grUnmangleSignature(var.type.mangledReturnType));

				if(var.type.baseType == GrBaseType.FunctionType)
					addInstruction(GrOpcode.AnonymousCall, 0u);
				else if(var.type.baseType == GrBaseType.TaskType)
					addInstruction(GrOpcode.AnonymousTask, 0u);
                else if(var.type.baseType == GrBaseType.VariantType) {
                    dstring meta = grMangleFunction(signature);
                    addInstruction(GrOpcode.VariantCall, registerStringConstant(meta));
                }
				else
					logError("Invalid anonymous type", "debug");

				/*foreach(anonFunc; anonymousFunctions) {
					if(anonFunc.name == currentFunction.name) {

						hasAnonFunc = true;
						break;
					}
				}*/
			}
			else {
                //Signature parsing, no coercion is made
                if(get().type != GrLexemeType.RightParenthesis) {
                    for(;;) {
                        auto type = parseSubExpression(false, false, true, true);
                        if(type.baseType == GrBaseType.InternalTupleType) {
                            auto types = grUnpackTuple(type);
                            if(types.length)
                                signature ~= types;
                            else
                                logError("Cannot use a void function", "Cannot use a void function as a parameter");
                        }
                        else
                            signature ~= type;

                        if(get().type == GrLexemeType.RightParenthesis)
                            break;
                        advance();
                    }
                }
                checkAdvance();

                //Mangling function name
				dstring mangledName = grMangleNamedFunction(identifierName, signature);
				
				//GrPrimitive call.
				if(grIsPrimitiveDeclared(mangledName)) {
					GrPrimitive primitive = grGetPrimitive(mangledName);
					addInstruction(GrOpcode.PrimitiveCall, primitive.index);
					returnType = grPackTuple(primitive.outSignature);
				}
				else //GrFunction/Task call.
					returnType = grPackTuple(addFunctionCall(mangledName));
			}
		}
		else {
			//Declared variable.
			variable = getVariable(identifierName);
			returnType = variable.type;
            //If it's an assignement, we want the GET instruction to be after the assignement, not there.
            const auto nextLexeme = get();
            /*if(nextLexeme.type == GrLexemeType.LeftBracket) {
                addInstruction(GrOpcode.LocalLoad_UserData, variable.index);
                returnType = GrType(GrBaseType.VariantType);
            }
            else */if(nextLexeme.type != GrLexemeType.Assign)
                addGetInstruction(variable, expectedType);
		}
		return returnType;
	}

	//Error handling
	struct Error {
		dstring msg, info;
		GrLexeme lex;
		bool mustHalt;
	}

	Error[] errors;

	void logWarning(string msg, string info = "") {
		Error error;
		error.msg = to!dstring(msg);
		error.info = to!dstring(info);
		error.lex = get();
		error.mustHalt = false;
		errors ~= error;
	}

	void logError(string msg, string info = "") {
		Error error;
		error.msg = to!dstring(msg);
		error.info = to!dstring(info);
		error.mustHalt = true;
		if(isEnd()) {
			error.lex = get(-1);
		}
		else
			error.lex = get();

		errors ~= error;
		raiseError();
	}

	void raiseError() {
		foreach(error; errors) {
			dstring report;

			//Separator
			if(error.mustHalt)
				report ~= "\n\033[0;36m--\033[0;91m Error \033[0;36m-------------------- " ~ error.lex.lexer.file ~ "\033[0m\n";
			else
				report ~= "\n\033[0;36m--\033[0;93m Warning \033[0;36m-------------------- " ~ error.lex.lexer.file ~ "\033[0m\n";

			//Error report
			report ~= error.msg ~ ":\033[1;34m\n";

			//Script snippet
			dstring lineNumber = to!dstring(error.lex.line + 1u) ~ "| ";
			report ~= lineNumber;
			report ~= error.lex.getLine().replace("\t", " ") ~ "\n";

			//Red underline
			foreach(x; 1 .. lineNumber.length + error.lex.column)
				report ~= " ";

			if(error.mustHalt)
				report ~= "\033[1;31m"; //Red color
			else
				report ~= "\033[1;93m"; //Red color

            auto lexLength = error.lex.textLength;
            if(error.lex.type == GrLexemeType.String)
                lexLength += 2;
			foreach(x; 0 .. lexLength)
				report ~= "^";
			report ~= "\033[0m\n"; //White color

			//Error description
			if(error.info.length)
				report ~= error.info ~ ".\n";
			writeln(report);
		}
		throw new Exception("\033[0mCompilation aborted...");
	}
}