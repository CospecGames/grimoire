/**
    The parser analyses the lexemes generated by the lexer and produce machine code.

    Copyright: (c) Enalye 2018
    License: Zlib
    Authors: Enalye
*/

module grimoire.compiler.parser;

import std.stdio;
import std.string;
import std.array;
import std.conv;
import std.math;
import std.file;
import std.meta;

import grimoire.runtime;
import grimoire.assembly;
import grimoire.compiler.lexer;
import grimoire.compiler.mangle;
import grimoire.compiler.type;
import grimoire.compiler.primitive;

/**
    Analyses the syntax and produce the data for the VM
*/
class GrParser {
	int[] iconsts;
	float[] fconsts;
	dstring[] sconsts;

	uint scopeLevel;

	GrVariable[dstring] globalVariables;
    uint globalVariableIndex;
    uint[] globalFreeVariables;

	GrFunction[dstring] functions, events;
	GrFunction[] anonymousFunctions;

	uint current;
	GrFunction currentFunction;
	GrFunction[] functionStack;
	GrFunctionCall[] functionCalls;

	uint[][] breaksJumps;
	uint[][] continuesJumps;
	uint[] continuesDestinations;

	GrLexeme[] lexemes;

    /// Reset to the start of the sequence.
	void reset() {
		current = 0u;
	}

    /// Advance to the next lexeme.
	void advance() {
		if(current < lexemes.length)
			current ++;
	}

    /// Return to the last lexeme.
    void goBack() {
        if(current > 0u)
            current --;
    }

    /// Check for the end the sequence, then advance to the next lexeme.
	bool checkAdvance() {
		if(isEnd())
			return false;
		
		advance();
		return true;
	}

    /// Start of a block with `{`
	void openBlock() {
		scopeLevel ++;
	}

    /// End of a block with '}'
	void closeBlock() {
		scopeLevel --;
	}

    /// Check for the end of the sequence.
	bool isEnd(int offset = 0) {
		return (current + offset) >= cast(uint)lexemes.length;
	}

    /// Return the lexeme at the current position.
	GrLexeme get(int offset = 0) {
		uint position = current + offset;
		if(position < 0 || position >= cast(uint)lexemes.length) {
			logError("Unexpected end of file");
		}
		return lexemes[position];
	}

    /// Register an integral value and returns its id.
	uint registerIntConstant(int value) {
		foreach(uint index, int iconst; iconsts) {
			if(iconst == value)
				return index;
		}
		iconsts ~= value;
		return cast(uint)iconsts.length - 1;
	}

    /// Register an floating point value and returns its id.
	uint registerFloatConstant(float value) {
		foreach(uint index, float fconst; fconsts) {
			if(fconst == value)
				return index;
		}
		fconsts ~= value;
		return cast(uint)fconsts.length - 1;
	}

    /// Register an string value and returns its id.
	uint registerStringConstant(dstring value) {
		foreach(uint index, dstring sconst; sconsts) {
			if(sconst == value)
				return index;
		}
		sconsts ~= value;
		return cast(uint)sconsts.length - 1;
	}

    /// Register a special local variable, used for iterators, etc.
	GrVariable registerSpecialVariable(dstring name, GrType type) {
		name = "~"d ~ name;
		GrVariable specialVariable;
		auto previousVariable = (name in currentFunction.localVariables);
		if(previousVariable is null)
			specialVariable = registerLocalVariable(name, type);
		else
			specialVariable = *previousVariable;
        specialVariable.isAuto = false;
        specialVariable.isInitialized = true; //We shortcut this check
		return specialVariable;
	}

    /// Register a global variable
    GrVariable registerGlobalVariable(dstring name, GrType type) {
        if(type.baseType == GrBaseType.StructType) {
            //Register each field
            auto structure = grGetStructure(type.mangledType);
            for(int i; i < structure.signature.length; i ++) {
                registerLocalVariable(name ~ "." ~ structure.fields[i], structure.signature[i]);
            }
            //Register the struct itself with the id of the first field
            auto previousVariable = (name in globalVariables);
            if(previousVariable !is null)
                logError("Multiple declaration", "The global variable \'" ~ to!string(name) ~ "\' is already declared.");

            GrVariable variable = new GrVariable;
            variable.index = globalVariableIndex;
            variable.isGlobal = true;
            variable.isInitialized = false;
            variable.type = type;
            variable.name = name;
            globalVariables[name] = variable;

            return variable;
        }

        //Check if declared globally.
		auto previousVariable = (name in globalVariables);
		if(previousVariable !is null)
			logError("Multiple declaration", "The global variable \'" ~ to!string(name) ~ "\' is already declared.");

		GrVariable variable = new GrVariable;
        if(globalFreeVariables.length) {
            variable.index = globalFreeVariables[$ - 1];
            globalFreeVariables.length --;
        }
        else {
            variable.index = globalVariableIndex;
            globalVariableIndex ++;
        }
		variable.isGlobal = true;
        variable.isInitialized = false;
		variable.type = type;
        variable.name = name;
		globalVariables[name] = variable;

		return variable;
    }

    /// Register a local variable
	GrVariable registerLocalVariable(dstring name, GrType type) {
        if(type.baseType == GrBaseType.StructType) {
            //Register each field
            auto structure = grGetStructure(type.mangledType);
            for(int i; i < structure.signature.length; i ++) {
                registerLocalVariable(name ~ "." ~ structure.fields[i], structure.signature[i]);
            }
            //Register the struct itself with the id of the first field
            auto previousVariable = (name in currentFunction.localVariables);
            if(previousVariable !is null)
                logError("Multiple declaration", "The local variable \'" ~ to!string(name) ~ "\' is already declared.");

            GrVariable variable = new GrVariable;
            variable.index = currentFunction.localVariableIndex;
            variable.isGlobal = false;
            variable.type = type;
            variable.name = name;
            currentFunction.localVariables[name] = variable;

            return variable;
        }
		//Check if declared globally
        if(name in globalVariables)
			logError("Multiple declaration", "The local variable \'" ~ to!string(name) ~ "\' is already declared in a global scope.");

		//Check if declared locally.
		auto previousVariable = (name in currentFunction.localVariables);
		if(previousVariable !is null)
			logError("Multiple declaration", "The local variable \'" ~ to!string(name) ~ "\' is already declared.");

		GrVariable variable = new GrVariable;
        if(currentFunction.localFreeVariables.length) {
            variable.index = currentFunction.localFreeVariables[$ - 1];
            currentFunction.localFreeVariables.length --;
        }
        else {
		    variable.index = currentFunction.localVariableIndex;
            currentFunction.localVariableIndex ++;
        }
		variable.isGlobal = false;
		variable.type = type;
        variable.name = name;
		currentFunction.localVariables[name] = variable;

		return variable;
	}

    void beginGlobalScope() {
        auto globalScope = "@global"d in functions;
        if(globalScope) {
            functionStack ~= currentFunction;
            currentFunction = *globalScope;
        }
        else {
            GrFunction func = new GrFunction;
            func.name = "@global"d;
            func.isTask = false;
            func.signature = [];
            func.returnType = grVoid;
            functions["@global"d] = func;
            functionStack ~= currentFunction;
            currentFunction = func;
        }
    }

    void endGlobalScope() {
        if(!functionStack.length)
			logError("Global Scope", "Global scope mismatch");
        
		currentFunction = functionStack[$ - 1];
        functionStack.length --;
    }

	void beginFunction(dstring name, GrType[] signature, bool isEvent = false) {
        const dstring mangledName = grMangleNamedFunction(name, signature);

		GrFunction* func;
        if(isEvent)
            func = mangledName in events;
        else
            func = mangledName in functions;

		if(func is null)
			logError("Undeclared function", "The function \'" ~ to!string(name) ~ "\' is not declared.");

		functionStack ~= currentFunction;
		currentFunction = *func;
	}

	void preBeginFunction(dstring name, GrType[] signature, dstring[] inputVariables, bool isTask, GrType returnType = GrBaseType.VoidType, bool isAnonymous = false, bool isEvent = false) {
		GrFunction func = new GrFunction;
		func.isTask = isTask;
		func.signature = signature;
		func.returnType = returnType;

		if(isAnonymous) {
			func.index = cast(uint)anonymousFunctions.length;
			func.anonParent = currentFunction;
			func.anonReference = cast(uint)currentFunction.instructions.length;
			func.name = currentFunction.name ~ "@anon"d ~ to!dstring(func.index);
			anonymousFunctions ~= func;

			//Is replaced by the addr of the function later (see solveFunctionCalls).
			addInstruction(GrOpcode.LocalStore_Int, 0u);
		}
		else {
			func.index = cast(uint)functions.length;
			func.name = name;

			dstring mangledName = grMangleNamedFunction(name, signature);
			auto previousFunc = (mangledName in functions);
			if(previousFunc !is null)
				logError("Multiple declaration", "The function \'" ~ to!string(name) ~ "\' is already declared.");
		
            if(isEvent)
			    events[mangledName] = func;
            else
			    functions[mangledName] = func;
		}

		functionStack ~= currentFunction;
		currentFunction = func;

		addInstruction(GrOpcode.LocalStack, 0u);

		void fetchParameter(dstring name, GrType type) {
            final switch(type.baseType) with(GrBaseType) {
            case VoidType:
                logError("Invalid type", "Void is not a valid parameter type");
                break;
            case IntType:
            case BoolType:
            case FunctionType:
            case TaskType:
                func.nbIntegerParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_Int, 0u);
                break;
            case FloatType:
                func.nbFloatParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_Float, 0u);
                break;
            case StringType:
                func.nbStringParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_String, 0u);
                break;
            case ArrayType:
                func.nbArrayParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_Array, 0u);
                break;
            case DynamicType:
                func.nbAnyParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_Any, 0u);
                break;
            case ObjectType:
                func.nbObjectParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_Object, 0u);
                break;
            case StructType:
                auto structure = grGetStructure(type.mangledType);
                const auto nbFields = structure.signature.length;
                for(int i = 1; i <= structure.signature.length; i ++) {
                    fetchParameter(name ~ "." ~ structure.fields[nbFields - i], structure.signature[nbFields - i]);
                }
                break;
            case UserType:
                func.nbUserDataParameters ++;
                if(func.isTask)
                    addInstruction(GrOpcode.GlobalPop_UserData, 0u);
                break;
            }

            GrVariable newVar = new GrVariable;
            newVar.type = type;
            newVar.isInitialized = true;
            newVar.index = func.localVariableIndex;
            if(type.baseType != GrBaseType.StructType)
                func.localVariableIndex ++;
            newVar.isGlobal = false;
            newVar.name = name;
            func.localVariables[name] = newVar;
            if(type.baseType != GrBaseType.StructType)
                addSetInstruction(newVar);
        }

        foreach_reverse(size_t i, inputVariable; inputVariables) {
            fetchParameter(inputVariables[i], signature[i]);
        }
	}

	void endFunction() {
		setInstruction(GrOpcode.LocalStack, 0u, currentFunction.localVariableIndex);
		if(!functionStack.length)
			logError("Missing symbol", "A \'}\' is missing, causing a mismatch");
        
		currentFunction = functionStack[$ - 1];
        functionStack.length --;
	}

	void preEndFunction() {
		if(!functionStack.length)
			logError("Missing symbol", "A \'}\' is missing, causing a mismatch");
		currentFunction = functionStack[$ - 1];
        functionStack.length --;
	}

	GrFunction* getFunction(dstring name) {
		auto func = (name in functions);
		if(func is null)
			logError("Undeclared function", "The function \'" ~ to!string(name) ~ "\' is not declared");
		return func;
	}

    /// Retrieve a declared variable
	GrVariable getVariable(dstring name) {
        auto var = (name in globalVariables);
		if(var !is null)
            return *var;

		var = (name in currentFunction.localVariables);
		if(var is null)
		    logError("Undeclared variable", "The variable \'" ~ to!string(name) ~ "\' is not declared");
        return *var;
	}

	void addIntConstant(int value) {
		addInstruction(GrOpcode.Const_Int, registerIntConstant(value));
	}

	void addFloatConstant(float value) {
		addInstruction(GrOpcode.Const_Float, registerFloatConstant(value));
	}

	void addBoolConstant(bool value) {
		addInstruction(GrOpcode.Const_Bool, value);
	}

	void addStringConstant(dstring value) {
		addInstruction(GrOpcode.Const_String, registerStringConstant(value));
	}

	void addInstruction(GrOpcode opcode, int value = 0, bool isSigned = false) {
		if(currentFunction is null)
			logError("Not in function", "The expression is located outside of a function or task, which is forbidden");

		GrInstruction instruction;
		instruction.opcode = opcode;
		if(isSigned) {
			if((value >= 0x800000) || (-value >= 0x800000))
				logError("Internal failure", "An opcode\'s signed value is exceeding limits");		
			instruction.value = value + 0x800000;
		}
		else
			instruction.value = value;
		currentFunction.instructions ~= instruction;
	}

	void setInstruction(GrOpcode opcode, uint index, int value = 0u, bool isSigned = false) {
		if(currentFunction is null)
			logError("Not in function", "The expression is located outside of a function or task, which is forbidden");

		if(index >= currentFunction.instructions.length)
			logError("Internal failure", "An instruction's index is exeeding the function size");

		GrInstruction instruction;
		instruction.opcode = opcode;
		if(isSigned) {
			if((value >= 0x800000) || (-value >= 0x800000))
				logError("Internal failure", "An opcode\'s signed value is exceeding limits");				
			instruction.value = value + 0x800000;
		}
		else
			instruction.value = value;
		currentFunction.instructions[index] = instruction;
	}

    bool isBinaryOperator(GrLexemeType lexType) {
        if(lexType >= GrLexemeType.Add && lexType <= GrLexemeType.Xor)
            return true;
        else
            return false;
    }

    bool isUnaryOperator(GrLexemeType lexType) {
        if(lexType >= GrLexemeType.Plus && lexType <= GrLexemeType.Minus)
            return true;
        else if(lexType >= GrLexemeType.Increment && lexType <= GrLexemeType.Decrement)
            return true;
        else
            return false;
    }

    GrType addCustomBinaryOperator(GrLexemeType lexType, GrType leftType, GrType rightType) {
        GrType resultType = GrBaseType.VoidType;
        dstring mangledName = grMangleNamedFunction("@op_" ~ grLexer_getTypeDisplay(lexType), [leftType, rightType]);
        
        //GrPrimitive check
        if(grIsPrimitiveDeclared(mangledName)) {
            GrPrimitive primitive = grGetPrimitive(mangledName);
            addInstruction(GrOpcode.PrimitiveCall, primitive.index);
            resultType = primitive.returnType;
        }

        //GrFunction check
        if(resultType.baseType == GrBaseType.VoidType) {
    		auto func = (mangledName in functions);
            if(func !is null) {
                resultType = addFunctionCall(mangledName);
            }
        }

        return resultType;     
    }

    GrType addCustomUnaryOperator(GrLexemeType lexType, GrType type) {
        GrType resultType = GrBaseType.VoidType;
        dstring mangledName = grMangleNamedFunction("@op_" ~ grLexer_getTypeDisplay(lexType), [type]);
        
        //GrPrimitive check
        if(grIsPrimitiveDeclared(mangledName)) {
            GrPrimitive primitive = grGetPrimitive(mangledName);
            addInstruction(GrOpcode.PrimitiveCall, primitive.index);
            resultType = primitive.returnType;
        }

        //GrFunction check
        if(resultType.baseType == GrBaseType.VoidType) {
    		auto func = (mangledName in functions);
            if(func !is null) {
                resultType = addFunctionCall(mangledName);
            }
        }

        return resultType;     
    }

    GrType addBinaryOperator(GrLexemeType lexType, GrType leftType, GrType rightType) {
        GrType resultType = GrBaseType.VoidType;

        if(leftType != rightType) {
            //Check custom operator
            resultType = addCustomBinaryOperator(lexType, leftType, rightType);

            //If there is no custom operator defined, we try to convert and then try again
            if(resultType.baseType == GrBaseType.VoidType) {
                resultType = convertType(rightType, leftType, true);
                if(resultType.baseType != GrBaseType.VoidType) {
                    resultType = addBinaryOperator(lexType, resultType, resultType);
                }
            }
        }
        else {
            resultType = addInternalOperator(lexType, leftType);
            if(resultType.baseType == GrBaseType.VoidType) {
                resultType = addCustomBinaryOperator(lexType, leftType, rightType);
            }
        }
        
        if(resultType.baseType == GrBaseType.VoidType)
            logError("Operator Undefined", "There is no "
                ~ to!string(grLexer_getTypeDisplay(lexType))
                ~ " operator defined for \'"
                ~ grGetPrettyType(leftType)
                ~ "\' and \'"
                ~ grGetPrettyType(rightType)
                ~ "\'");
        return resultType;
    }

    GrType addUnaryOperator(GrLexemeType lexType, GrType type) {
        GrType resultType = GrBaseType.VoidType;
        
        resultType = addInternalOperator(lexType, type);
        if(resultType.baseType == GrBaseType.VoidType) {
            resultType = addCustomUnaryOperator(lexType, type);
        }
    
        if(resultType.baseType == GrBaseType.VoidType)
            logError("Operator Undefined", "There is no "
                ~ to!string(grLexer_getTypeDisplay(lexType))
                ~ " operator defined for \'"
                ~ grGetPrettyType(type)
                ~ "\'");
        return resultType;
    }

	GrType addOperator(GrLexemeType lexType, ref GrType[] typeStack) {
        if(isBinaryOperator(lexType)) {
            typeStack[$ - 2] = addBinaryOperator(lexType, typeStack[$ - 2], typeStack[$ - 1]);
            typeStack.length --;
            return typeStack[$ - 1];
        }
        else if(isUnaryOperator(lexType)) {
            typeStack[$ - 1] = addUnaryOperator(lexType, typeStack[$ - 1]);
            return typeStack[$ - 1];
        }

        return GrType(GrBaseType.VoidType);		
	}

    GrType addInternalOperator(GrLexemeType lexType, GrType varType) {
        switch(varType.baseType) with(GrBaseType) {
        case BoolType:
            switch(lexType) with(GrLexemeType) {
            case And:
				addInstruction(GrOpcode.AndInt);
                return GrType(GrBaseType.BoolType);
			case Or:
				addInstruction(GrOpcode.OrInt);
                return GrType(GrBaseType.BoolType);
			case Not:
				addInstruction(GrOpcode.NotInt);
                return GrType(GrBaseType.BoolType);				
            default:
                break;
            }
            break;
		case IntType:
			switch(lexType) with(GrLexemeType) {
			case Add:
				addInstruction(GrOpcode.AddInt);
				return GrType(GrBaseType.IntType);
			case Substract:
				addInstruction(GrOpcode.SubstractInt);
				return GrType(GrBaseType.IntType);
			case Multiply:
				addInstruction(GrOpcode.MultiplyInt);
				return GrType(GrBaseType.IntType);
			case Divide:
				addInstruction(GrOpcode.DivideInt);
				return GrType(GrBaseType.IntType);
            case Remainder:
				addInstruction(GrOpcode.RemainderInt);
				return GrType(GrBaseType.IntType);
			case Minus:
				addInstruction(GrOpcode.NegativeInt);
				return GrType(GrBaseType.IntType);
			case Plus:
				return GrType(GrBaseType.IntType);
			case Increment:
				addInstruction(GrOpcode.IncrementInt);
				return GrType(GrBaseType.IntType);
			case Decrement:
				addInstruction(GrOpcode.DecrementInt);
				return GrType(GrBaseType.IntType);
			case Equal:
				addInstruction(GrOpcode.Equal_Int);
				return GrType(GrBaseType.BoolType);
			case NotEqual:
				addInstruction(GrOpcode.NotEqual_Int);
				return GrType(GrBaseType.BoolType);
			case Greater:
				addInstruction(GrOpcode.GreaterInt);
				return GrType(GrBaseType.BoolType);
			case GreaterOrEqual:
				addInstruction(GrOpcode.GreaterOrEqual_Int);
				return GrType(GrBaseType.BoolType);
			case Lesser:
				addInstruction(GrOpcode.LesserInt);
				return GrType(GrBaseType.BoolType);
			case LesserOrEqual:
				addInstruction(GrOpcode.LesserOrEqual_Int);
                return GrType(GrBaseType.BoolType);				
			default:
				break;
			}
			break;
		case FloatType:
			switch(lexType) with(GrLexemeType) {
			case Add:
				addInstruction(GrOpcode.AddFloat);
				return GrType(GrBaseType.FloatType);
			case Substract:
				addInstruction(GrOpcode.SubstractFloat);
				return GrType(GrBaseType.FloatType);
			case Multiply:
				addInstruction(GrOpcode.MultiplyFloat);
				return GrType(GrBaseType.FloatType);
			case Divide:
				addInstruction(GrOpcode.DivideFloat);
				return GrType(GrBaseType.FloatType);
            case Remainder:
				addInstruction(GrOpcode.RemainderFloat);
				return GrType(GrBaseType.FloatType);
			case Minus:
				addInstruction(GrOpcode.NegativeFloat);
				return GrType(GrBaseType.FloatType);
			case Plus:
				return GrType(GrBaseType.FloatType);
			case Increment:
				addInstruction(GrOpcode.IncrementFloat);
				return GrType(GrBaseType.FloatType);
			case Decrement:
				addInstruction(GrOpcode.DecrementFloat);
				return GrType(GrBaseType.FloatType);
			case Equal:
				addInstruction(GrOpcode.Equal_Float);
				return GrType(GrBaseType.BoolType);
			case NotEqual:
				addInstruction(GrOpcode.NotEqual_Float);
				return GrType(GrBaseType.BoolType);
			case Greater:
				addInstruction(GrOpcode.GreaterFloat);
				return GrType(GrBaseType.BoolType);
			case GreaterOrEqual:
				addInstruction(GrOpcode.GreaterOrEqual_Float);
				return GrType(GrBaseType.BoolType);
			case Lesser:
				addInstruction(GrOpcode.LesserFloat);
				return GrType(GrBaseType.BoolType);
			case LesserOrEqual:
				addInstruction(GrOpcode.LesserOrEqual_Float);
				return GrType(GrBaseType.BoolType);
			default:
				break;
			}
			break;
		case StringType:
			switch(lexType) with(GrLexemeType) {
			case Concatenate:
				addInstruction(GrOpcode.ConcatenateString);
				return GrType(GrBaseType.StringType);
			case Equal:
				addInstruction(GrOpcode.Equal_String);
				return GrType(GrBaseType.BoolType);
			case NotEqual:
				addInstruction(GrOpcode.NotEqual_String);
				return GrType(GrBaseType.BoolType);
			default:
				break;
			}
			break;
		case DynamicType:
			switch(lexType) with(GrLexemeType) {
			case Add:
				addInstruction(GrOpcode.AddAny);
				return GrType(GrBaseType.DynamicType);
			case Substract:
				addInstruction(GrOpcode.SubstractAny);
				return GrType(GrBaseType.DynamicType);
			case Multiply:
				addInstruction(GrOpcode.MultiplyAny);
				return GrType(GrBaseType.DynamicType);
			case Divide:
				addInstruction(GrOpcode.DivideAny);
				return GrType(GrBaseType.DynamicType);
            case Remainder:
				addInstruction(GrOpcode.RemainderAny);
				return GrType(GrBaseType.DynamicType);
			case Minus:
				addInstruction(GrOpcode.NegativeAny);
				return GrType(GrBaseType.DynamicType);
			case Plus:
				return GrType(GrBaseType.DynamicType);
			case Increment:
				addInstruction(GrOpcode.IncrementAny);
				return GrType(GrBaseType.DynamicType);
			case Decrement:
				addInstruction(GrOpcode.DecrementAny);
				return GrType(GrBaseType.DynamicType);
			case Concatenate:
				addInstruction(GrOpcode.ConcatenateAny);
				return GrType(GrBaseType.DynamicType);
			case Equal:
				addInstruction(GrOpcode.Equal_Any);
				return GrType(GrBaseType.DynamicType);
			case NotEqual:
				addInstruction(GrOpcode.NotEqual_Any);
				return GrType(GrBaseType.DynamicType);
			case Greater:
				addInstruction(GrOpcode.GreaterAny);
				return GrType(GrBaseType.DynamicType);
			case GreaterOrEqual:
				addInstruction(GrOpcode.GreaterOrEqual_Any);
				return GrType(GrBaseType.DynamicType);
			case Lesser:
				addInstruction(GrOpcode.LesserAny);
				return GrType(GrBaseType.DynamicType);
			case LesserOrEqual:
				addInstruction(GrOpcode.LesserOrEqual_Any);
				return GrType(GrBaseType.DynamicType);
			case And:
				addInstruction(GrOpcode.AndAny);
				return GrType(GrBaseType.DynamicType);
			case Or:
				addInstruction(GrOpcode.OrAny);
				return GrType(GrBaseType.DynamicType);
			case Not:
				addInstruction(GrOpcode.NotAny);
				return GrType(GrBaseType.DynamicType);
			default:
				break;
			}
			break;
		default:
            break;
		}
        return GrType(GrBaseType.VoidType);
    }

	void addSetInstruction(GrVariable variable, GrType valueType = GrBaseType.VoidType, bool isGettingValue = false) {
        if(variable is null) {
			addInstruction(isGettingValue ? GrOpcode.LocalStore2_Ref : GrOpcode.LocalStore_Ref);
            return;
        }
        
        if(variable.isAuto && !variable.isInitialized) {
            variable.isInitialized = true;
            variable.isAuto = false;
            variable.type = valueType;
            if(valueType.baseType == GrBaseType.StructType) {
                auto structure = grGetStructure(valueType.mangledType);
                if(variable.isGlobal) {
                    globalFreeVariables ~= variable.index;
                    for(int i; i < structure.signature.length; i ++) {
                        registerGlobalVariable(variable.name ~ "." ~ structure.fields[i], structure.signature[i]);
                    }
                }
                else {
                    currentFunction.localFreeVariables ~= variable.index;
                    for(int i; i < structure.signature.length; i ++) {
                        registerLocalVariable(variable.name ~ "." ~ structure.fields[i], structure.signature[i]);
                    }
                }
            }
            else if(valueType.baseType == GrBaseType.VoidType)
                logError("GrVariable type error", "Cannot infer the type of variable");
        }
        
        if(valueType.baseType != GrBaseType.VoidType)
            convertType(valueType, variable.type);

        if(!variable.isInitialized && isGettingValue)
            logError("Uninitialized variable", "The variable is being used without being assigned");
        variable.isInitialized = true;

		if(variable.isGlobal) {
			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_Int : GrOpcode.GlobalStore_Int, variable.index);
				break;
			case FloatType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_Float : GrOpcode.GlobalStore_Float, variable.index);
				break;
			case StringType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_String : GrOpcode.GlobalStore_String, variable.index);
				break;
            case ArrayType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_Array : GrOpcode.GlobalStore_Array, variable.index);
				break;
			case DynamicType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_Any : GrOpcode.GlobalStore_Any, variable.index);
				break;
			case ObjectType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_Object : GrOpcode.GlobalStore_Object, variable.index);
				break;
            case StructType:
                auto structure = grGetStructure(variable.type.mangledType);
                const auto nbFields = structure.signature.length;
                for(int i = 1; i <= nbFields; i ++) {
                    addSetInstruction(getVariable(variable.name ~ "." ~ structure.fields[nbFields - i]), structure.signature[nbFields - i]);
                }
                break;
            case UserType:
				addInstruction(isGettingValue ? GrOpcode.GlobalStore2_UserData : GrOpcode.GlobalStore_UserData, variable.index);
				break;
			default:
				logError("Invalid type", "Cannot assign to a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
		else {
			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_Int : GrOpcode.LocalStore_Int, variable.index);
				break;
			case FloatType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_Float : GrOpcode.LocalStore_Float, variable.index);
				break;
			case StringType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_String : GrOpcode.LocalStore_String, variable.index);
				break;
            case ArrayType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_Array : GrOpcode.LocalStore_Array, variable.index);
				break;
			case DynamicType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_Any : GrOpcode.LocalStore_Any, variable.index);
				break;
			case ObjectType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_Object : GrOpcode.LocalStore_Object, variable.index);
				break;
            case StructType:
                auto structure = grGetStructure(variable.type.mangledType);
                const auto nbFields = structure.signature.length;
                for(int i = 1; i <= nbFields; i ++) {
                    addSetInstruction(getVariable(variable.name ~ "." ~ structure.fields[nbFields - i]), structure.signature[nbFields - i]);
                }
                break;
            case UserType:
				addInstruction(isGettingValue ? GrOpcode.LocalStore2_UserData : GrOpcode.LocalStore_UserData, variable.index);
				break;
			default:
				logError("Invalid type", "Cannot assign to a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
	}

	void addGetInstruction(GrVariable variable, GrType expectedType = GrBaseType.VoidType) {
        if(variable.isGlobal) {
			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
				addInstruction(GrOpcode.GlobalLoad_Int, variable.index);
				break;
			case FloatType:
				addInstruction(GrOpcode.GlobalLoad_Float, variable.index);
				break;
			case StringType:
				addInstruction(GrOpcode.GlobalLoad_String, variable.index);
				break;
			case ArrayType:
				addInstruction(GrOpcode.GlobalLoad_Array, variable.index);
				break;
			case DynamicType:
				addInstruction(GrOpcode.GlobalLoad_Any, variable.index);
				break;
			case ObjectType:			
				addInstruction(GrOpcode.GlobalLoad_Object, variable.index);
				break;
            case StructType:
                auto structure = grGetStructure(variable.type.mangledType);
                for(int i; i < structure.signature.length; i ++) {
                    addGetInstruction(getVariable(variable.name ~ "." ~ structure.fields[i]), structure.signature[i]);
                }
                break;
            case UserType:			
				addInstruction(GrOpcode.GlobalLoad_UserData, variable.index);
				break;
			default:
				logError("Invalid type", "Cannot fetch from a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
		else {
            if(!variable.isInitialized)
                logError("Uninitialized variable", "The local variable is being used without being assigned");

			switch(variable.type.baseType) with(GrBaseType) {
			case BoolType:
			case IntType:
			case FunctionType:
			case TaskType:
				addInstruction(GrOpcode.LocalLoad_Int, variable.index);
				break;
			case FloatType:
				addInstruction(GrOpcode.LocalLoad_Float, variable.index);
				break;
			case StringType:
				addInstruction(GrOpcode.LocalLoad_String, variable.index);
				break;
			case ArrayType:
				addInstruction(GrOpcode.LocalLoad_Array, variable.index);
				break;
			case DynamicType:
				addInstruction(GrOpcode.LocalLoad_Any, variable.index);
				break;
			case ObjectType:			
				addInstruction(GrOpcode.LocalLoad_Object, variable.index);
				break;
            case StructType:
                auto structure = grGetStructure(variable.type.mangledType);
                for(int i; i < structure.signature.length; i ++) {
                    addGetInstruction(getVariable(variable.name ~ "." ~ structure.fields[i]), structure.signature[i]);
                }
                break;
            case UserType:			
				addInstruction(GrOpcode.LocalLoad_UserData, variable.index);
				break;
			default:
				logError("Invalid type", "Cannot fetch from a \'" ~ to!string(variable.type) ~ "\' type");
			}
		}
	}

    GrType addFunctionAddress(dstring mangledName) {
        GrFunctionCall call = new GrFunctionCall;
		call.mangledName = mangledName;
		call.caller = currentFunction;
		functionCalls ~= call;
		currentFunction.functionCalls ~= call;
        call.isAddress = true;

		auto func = (call.mangledName in functions);
		if(func !is null) {
		    call.functionToCall = *func;
            call.isAddress = true;
            call.position = cast(uint)currentFunction.instructions.length;
            addInstruction(GrOpcode.Const_Int, 0);

            return grGetFunctionAsType(*func);
        }

		return GrType(GrBaseType.VoidType);
    }

	GrType addFunctionCall(dstring mangledName) {
		GrFunctionCall call = new GrFunctionCall;
		call.mangledName = mangledName;
		call.caller = currentFunction;
		functionCalls ~= call;
		currentFunction.functionCalls ~= call;
        call.isAddress = false;

		auto func = (call.mangledName in functions);
		if(func !is null) {
			call.functionToCall = *func;
            if(func.isTask) {
                if(func.nbIntegerParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_Int, func.nbIntegerParameters);
                if(func.nbFloatParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_Float, func.nbFloatParameters);
                if(func.nbStringParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_String, func.nbStringParameters);
                if(func.nbArrayParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_Array, func.nbArrayParameters);
                if(func.nbAnyParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_Any, func.nbAnyParameters);
                if(func.nbObjectParameters > 0)
                    addInstruction(GrOpcode.GlobalPush_Object, func.nbObjectParameters);
            }

            call.position = cast(uint)currentFunction.instructions.length;
            addInstruction(GrOpcode.Call, 0);

			return func.returnType;
		}
		else
			logError("Undeclared function", "The function \'" ~ to!string(call.mangledName) ~ "\' is not declared");

		return GrType(GrBaseType.VoidType);
	}

	void setOpcode(ref uint[] opcodes, uint position, GrOpcode opcode, uint value = 0u, bool isSigned = false) {
		GrInstruction instruction;
		instruction.opcode = opcode;
		if(isSigned) {
			if((value >= 0x800000) || (-value >= 0x800000))
				logError("Internal failure", "An opcode\'s signed value is exceeding limits");	
			instruction.value = value + 0x800000;
		}
		else
			instruction.value = value;

		uint makeOpcode(uint instr, uint value) {
			return ((value << 8u) & 0xffffff00) | (instr & 0xff);
		}
		opcodes[position] = makeOpcode(cast(uint)instruction.opcode, instruction.value);
	}

	void solveFunctionCalls(ref uint[] opcodes) {
		foreach(GrFunctionCall call; functionCalls) {
			auto func = (call.mangledName in functions);
			if(func !is null) {
                if(call.isAddress)
                    setOpcode(opcodes, call.position, GrOpcode.Const_Int, registerIntConstant(func.position));
				else if(func.isTask)
					setOpcode(opcodes, call.position, GrOpcode.Task, func.position);
				else
					setOpcode(opcodes, call.position, GrOpcode.Call, func.position);
			}
			else
				logError("Undeclared function", "The function \'" ~ to!string(call.mangledName) ~ "\' is not declared");
		}

		foreach(func; anonymousFunctions)
			setOpcode(opcodes, func.anonParent.position + func.anonReference, GrOpcode.Const_Int, registerIntConstant(func.position));
	}

	void dump() {
		writeln("Code Generated:\n");
		foreach(uint i, int ivalue; iconsts)
			writeln(".iconst " ~ to!string(ivalue) ~ "\t;" ~ to!string(i));

		foreach(uint i, float fvalue; fconsts)
			writeln(".fconst " ~ to!string(fvalue) ~ "\t;" ~ to!string(i));

		foreach(uint i, dstring svalue; sconsts)
			writeln(".sconst " ~ to!string(svalue) ~ "\t;" ~ to!string(i));

		foreach(dstring funcName, GrFunction func; functions) {
			if(func.isTask)
				writeln("\n.task " ~ funcName);
			else
				writeln("\n.function " ~ funcName);

			foreach(uint i, GrInstruction instruction; func.instructions) {
				writeln("[" ~ to!string(i) ~ "] " ~ to!string(instruction.opcode) ~ " " ~ to!string(instruction.value));
			}
		}
	}

	void parseScript(GrLexer lexer) {
		preParseScript(lexer);
		reset();

		lexemes = lexer.lexemes;

		while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Struct:
                skipDeclaration();
                break;
			case Main:
				parseMainDeclaration();
				break;
            case Event:
                parseEventDeclaration();
                break;
			case TaskType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				parseTaskDeclaration();
				break;
			case FunctionType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				parseFunctionDeclaration();
				break;
            case VoidType: .. case DynamicType:
            case AutoType:
            case Identifier:
                skipExpression();
                break;
			default:
				logError("Invalid type", "The type should be either main, func or task");
			}
		}
	}

	void preParseScript(GrLexer lexer) {
		lexemes = lexer.lexemes;

        //Structure definitions
        while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Struct:
                parseStructureDeclaration();
                break;
			case Main:
            case Event:
			case TaskType:
			case FunctionType:
				skipDeclaration();
				break;
			default:
				skipExpression();
                break;
			}
		}

        //Resolve all unresolved struct field types
        grResolveStructSignature();

        //Then we can resolve primitives' signature
        grResolvePrimitiveSignature();
        
        //Function definitions
        reset();
		while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Struct:
                skipDeclaration();
                break;
			case Main:
				preParseMainDeclaration();
				break;
            case Event:
                preParseEventDeclaration();
                break;
			case TaskType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				preParseTaskDeclaration();
				break;
			case FunctionType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				preParseFunctionDeclaration();
				break;
            case VoidType: .. case DynamicType:
            case AutoType:
            case Identifier:
                skipExpression();
                break;
			default:
				logError("Invalid type", "The type should be either main, func, task or struct");
			}
		}

        //Global variable definitions
        reset();
        beginGlobalScope();
		while(!isEnd()) {
			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
            case Event:
            case Struct:
			case Main:
				skipDeclaration();
				break;
			case TaskType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
				skipDeclaration();
				break;
			case FunctionType:
                if(get(1).type != GrLexemeType.Identifier)
                    goto case VoidType;
    			skipDeclaration();
                break;
            case VoidType: .. case DynamicType:
            case AutoType:
                parseGlobalDeclaration();
                break;
            case Identifier:
                if(grIsStructure(get().svalue) || grIsUserType(get().svalue)) {
                    parseGlobalDeclaration();
                    break;
                }
                goto default;
			default:
				logError("Invalid type", "The type should be either main, func, task or struct");
			}
		}
        endGlobalScope();
	}

    void parseStructureDeclaration() {
		checkAdvance();
        if(get().type != GrLexemeType.Identifier)
            logError("Missing Identifier", "struct must have a name");
        dstring structName = get().svalue;
        checkAdvance();
        if(get().type != GrLexemeType.LeftCurlyBrace)
            logError("Missing {", "struct does not have a body");
        checkAdvance();

        dstring[] fields;
        GrType[] signature;
        while(!isEnd()) {
            if(get().type == GrLexemeType.VoidType)
                logError("Field type error", "Void is not a valid field type");
            else if(get().type == GrLexemeType.RightCurlyBrace) {
                checkAdvance();
                break;
            }

            //Lazy check because we can't know about other structures
            auto fieldType = parseType(false);
            checkAdvance();

            //Unresolved type
            if(fieldType.baseType == GrBaseType.VoidType) {
                fieldType.mangledType = get().svalue;
                checkAdvance();
            }
            
            if(get().type != GrLexemeType.Identifier)
                logError("Missing Identifier", "struct field must have a name");

            auto fieldName = get().svalue;
            checkAdvance();

            signature ~= fieldType;
            fields ~= fieldName;

            if(get().type != GrLexemeType.Semicolon) 
                logError("Missing ;", "right there");
            checkAdvance();

            if(get().type == GrLexemeType.RightCurlyBrace) {
                checkAdvance();
                break;
            }
        }
        grAddStructure(structName, fields, signature);
    }

    void skipDeclaration() {
        checkAdvance();
        while(!isEnd()) {
            if(get().type != GrLexemeType.LeftCurlyBrace) {
                checkAdvance();
            }
            else {
                skipBlock();
                return;
            }
        }
    }

    void skipExpression() {
        checkAdvance();
        while(!isEnd()) {
            if(get().type != GrLexemeType.Semicolon) {
                checkAdvance();
            }
            else {
                checkAdvance();
                return;
            }
        }
    }

    GrType parseType(bool mustBeType = true) {
        GrType currentType = GrBaseType.VoidType;

        GrLexeme lex = get();
        if(!lex.isType) {
            if(lex.type == GrLexemeType.Identifier && grIsStructure(lex.svalue)) {
                currentType.baseType = GrBaseType.StructType;
                currentType.mangledType = lex.svalue;
                return currentType;
            }
            else if(lex.type == GrLexemeType.Identifier && grIsUserType(lex.svalue)) {
                currentType.baseType = GrBaseType.UserType;
                currentType.mangledType = lex.svalue;
                return currentType;
            }
            else if(mustBeType) {
                logError("Excepted type", "A valid type is expected");
            }
            else {
                goBack();
                return currentType;
            }
        }

        switch(lex.type) with(GrLexemeType) {
        case VoidType:
            currentType.baseType = GrBaseType.VoidType;
            break;
        case IntType:
            currentType.baseType = GrBaseType.IntType;
            break;
        case FloatType:
            currentType.baseType = GrBaseType.FloatType;
            break;
        case BoolType:
            currentType.baseType = GrBaseType.BoolType;
            break;
        case StringType:
            currentType.baseType = GrBaseType.StringType;
            break;
        case ObjectType:
            currentType.baseType = GrBaseType.ObjectType;
            break;
        case ArrayType:
            currentType.baseType = GrBaseType.ArrayType;
            break;
        case DynamicType:
            currentType.baseType = GrBaseType.DynamicType;
            break;
        case FunctionType:
            currentType.baseType = GrBaseType.FunctionType;
            dstring[] temp; 
            currentType.mangledType = grMangleNamedFunction("", parseSignature(temp, true));
            currentType.mangledReturnType = grMangleNamedFunction("", [parseType(false)]);
            break;
        case TaskType:
            currentType.baseType = GrBaseType.TaskType;
            dstring[] temp; 
            currentType.mangledType = grMangleNamedFunction("", parseSignature(temp, true));
            currentType.mangledReturnType = grMangleNamedFunction("", [parseType(false)]);
            break;
        default:
            logError("Invalid type", "Cannot call a function with a parameter of type \'" ~ to!string(lex.type) ~ "\'");
        }

        return currentType;
    }

    void addGlobalPop(GrType type) {
        final switch(type.baseType) with(GrBaseType) {
        case VoidType:
            logError("Invalid type", "Void is not a valid parameter type");
            break;
        case IntType:
        case BoolType:
        case FunctionType:
        case TaskType:
            addInstruction(GrOpcode.GlobalPop_Int, 0u);
            break;
        case FloatType:
            addInstruction(GrOpcode.GlobalPop_Float, 0u);
            break;
        case StringType:
            addInstruction(GrOpcode.GlobalPop_String, 0u);
            break;
        case ArrayType:
            addInstruction(GrOpcode.GlobalPop_Array, 0u);
            break;
        case DynamicType:
            addInstruction(GrOpcode.GlobalPop_Any, 0u);
            break;
        case ObjectType:
            addInstruction(GrOpcode.GlobalPop_Object, 0u);
            break;
        case StructType:
            auto structure = grGetStructure(type.mangledType);
            for(int i; i < structure.signature.length; i ++) {
                addGlobalPop(structure.signature[i]);
            }
            break;
        case UserType:
            addInstruction(GrOpcode.GlobalPop_UserData, 0u);
            break;
        }
    }

    void addGlobalPush(GrType type, int nbPush = 1u) {
        if(nbPush == 0)
            return;
        final switch(type.baseType) with(GrBaseType) {
        case VoidType:
            logError("Invalid type", "Void is not a valid parameter type");
            break;
        case IntType:
        case BoolType:
        case FunctionType:
        case TaskType:
            addInstruction(GrOpcode.GlobalPush_Int, nbPush);
            break;
        case FloatType:
            addInstruction(GrOpcode.GlobalPush_Float, nbPush);
            break;
        case StringType:
            addInstruction(GrOpcode.GlobalPush_String, nbPush);
            break;
        case ArrayType:
            addInstruction(GrOpcode.GlobalPush_Array, nbPush);
            break;
        case DynamicType:
            addInstruction(GrOpcode.GlobalPush_Any, nbPush);
            break;
        case ObjectType:
            addInstruction(GrOpcode.GlobalPush_Object, nbPush);
            break;
        case StructType:
            auto structure = grGetStructure(type.mangledType);
            for(int i = 1; i <= structure.signature.length; i ++) {
                addGlobalPush(structure.signature[structure.signature.length - i], nbPush);
            }
            break;
        case UserType:
            addInstruction(GrOpcode.GlobalPush_UserData, nbPush);
            break;
        }
    }

    void addGlobalPush(GrType[] signature) {
        struct TypeCounter {
            uint nbIntParams, nbFloatParams, nbStringParams,
                nbArrayParams, nbDynamicParams, nbObjectParams, nbUserDataParams;
        }
        void countParameters(ref TypeCounter typeCounter, GrType type) {
            final switch(type.baseType) with(GrBaseType) {
            case VoidType:
                logError("Invalid type", "Void is not a valid parameter type");
                break;
            case IntType:
            case BoolType:
            case FunctionType:
            case TaskType:
                typeCounter.nbIntParams ++;
                break;
            case FloatType:
                typeCounter.nbFloatParams ++;
                break;
            case StringType:
                typeCounter.nbStringParams ++;
                break;
            case ArrayType:
                typeCounter.nbArrayParams ++;
                break;
            case DynamicType:
                typeCounter.nbDynamicParams ++;
                break;
            case ObjectType:
                typeCounter.nbObjectParams ++;
                break;
            case StructType:
                auto structure = grGetStructure(type.mangledType);
                for(int i = 1; i <= structure.signature.length; i ++) {
                    countParameters(typeCounter, structure.signature[structure.signature.length - i]);
                }
                break;
            case UserType:
                typeCounter.nbUserDataParams ++;
                break;
            }
        }

        TypeCounter typeCounter;
        foreach(type; signature) {
            countParameters(typeCounter, type);
        }

        if(typeCounter.nbIntParams > 0)
            addInstruction(GrOpcode.GlobalPush_Int, typeCounter.nbIntParams);
        if(typeCounter.nbFloatParams > 0)
            addInstruction(GrOpcode.GlobalPush_Float, typeCounter.nbFloatParams);
        if(typeCounter.nbStringParams > 0)
            addInstruction(GrOpcode.GlobalPush_String, typeCounter.nbStringParams);
        if(typeCounter.nbArrayParams > 0)
            addInstruction(GrOpcode.GlobalPush_Array, typeCounter.nbArrayParams);
        if(typeCounter.nbDynamicParams > 0)
            addInstruction(GrOpcode.GlobalPush_Any, typeCounter.nbDynamicParams);
        if(typeCounter.nbObjectParams > 0)
            addInstruction(GrOpcode.GlobalPush_Object, typeCounter.nbObjectParams);
        if(typeCounter.nbUserDataParams > 0)
            addInstruction(GrOpcode.GlobalPush_UserData, typeCounter.nbUserDataParams);
    }

	GrType[] parseSignature(ref dstring[] inputVariables, bool asType = false) {
		GrType[] signature;

		checkAdvance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A signature should always start with \'(\'");

        bool startLoop = true;
		for(;;) {
			checkAdvance();
			GrLexeme lex = get();

			if(startLoop && lex.type == GrLexemeType.RightParenthesis)
				break;
            startLoop = false;

            signature ~= parseType();

            //Is it a function type or a function declaration ?
            if(!asType) {
                checkAdvance();
                lex = get();
                if(get().type != GrLexemeType.Identifier)
                    logError("Missing identifier", "Expected a name such as \'foo\'");
                inputVariables ~= lex.svalue;
            }

			checkAdvance();
			lex = get();
			if(lex.type == GrLexemeType.RightParenthesis)
				break;
			else if(lex.type != GrLexemeType.Comma)
				logError("Missing symbol", "Either a \',\' or a \')\' is expected");
		}

		checkAdvance();

		return signature;
	}

	void parseMainDeclaration() {
		checkAdvance();
		beginFunction("main", []);
        
        openDeferrableSection();
		parseBlock();
		addKill();
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
	}

	void preParseMainDeclaration() {
		checkAdvance();
		preBeginFunction("main", [], [], false);
		skipBlock();
		preEndFunction();
	}

    void parseEventDeclaration() {
        checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
		dstring[] inputs;
		GrType[] signature = parseSignature(inputs);
		beginFunction(name, signature, true);
        
        openDeferrableSection();
		parseBlock();
		addKill();
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
    }

    void preParseEventDeclaration() {
        checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
		dstring[] inputs;
		GrType[] signature = parseSignature(inputs);
		preBeginFunction(name, signature, inputs, false, grVoid, false, true);
		skipBlock();
		preEndFunction();
    }

	void parseTaskDeclaration() {
		checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
		dstring[] inputs;
		GrType[] signature = parseSignature(inputs);
		beginFunction(name, signature);

        openDeferrableSection();
		parseBlock();
		addKill();
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
	}

	void preParseTaskDeclaration() {
		checkAdvance();
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");
		dstring name = get().svalue;
		dstring[] inputs;
		GrType[] signature = parseSignature(inputs);
		preBeginFunction(name, signature, inputs, true);
		skipBlock();
		preEndFunction();
	}

	void parseFunctionDeclaration() {
		checkAdvance();
        dstring name;
        bool isConversion;
        if(get().type == GrLexemeType.As) {
            name = "@as";
            isConversion = true;
        }
        else {
            if(get().type != GrLexemeType.Identifier)
                logError("Missing identifier", "Expected a name such as \'foo\'");
            name = get().svalue;

            if(name == "operator") {
                checkAdvance();
                if(get().type >= GrLexemeType.Add && get().type <= GrLexemeType.Not) {
                    name = "@op_" ~ grLexer_getTypeDisplay(get().type);
                }
                else
                    logError("Invalid Operator", "The specified operator must be valid");
            }
        }
		dstring[] inputs;
		GrType[] signature = parseSignature(inputs);

        if(isConversion) {
            if(signature.length != 1uL)
                logError("Invalid format", "A conversion function has to take only 1 parameter and be non-void");
            GrType retType = parseType();
            if(retType.baseType == GrBaseType.VoidType)
                logError("Invalid format", "A conversion function has to take only 1 parameter and be non-void");

            signature ~= retType;
        }
        else
		    parseType(false);
        checkAdvance();

		beginFunction(name, signature);
        openDeferrableSection();
		parseBlock();
        if(currentFunction.instructions.length
            && currentFunction.instructions[$ - 1].opcode != GrOpcode.Return)
		    addReturn();
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();
	}

	void preParseFunctionDeclaration() {
		checkAdvance();
        dstring name;
        bool isConversion;
        if(get().type == GrLexemeType.As) {
            name = "@as";
            isConversion = true;
        }
        else {
            if(get().type != GrLexemeType.Identifier)
                logError("Missing identifier", "Expected a name such as \'foo\'");
            name = get().svalue;
            if(name == "operator") {
                checkAdvance();
                if(get().type >= GrLexemeType.Add && get().type <= GrLexemeType.Not) {
                    name = "@op_" ~ grLexer_getTypeDisplay(get().type);
                }
                else
                    logError("Invalid Operator", "The specified operator must be valid");
            }
        }
		dstring[] inputs;
		GrType[] signature = parseSignature(inputs);

		//Return Type.
        GrType returnType;
        if(isConversion) {
            if(signature.length != 1uL)
                logError("Invalid format", "A conversion function has to take only 1 parameter and be non-void");
            returnType = parseType();
            if(returnType.baseType == GrBaseType.VoidType)
                logError("Invalid format", "A conversion function has to take only 1 parameter and be non-void");

            signature ~= returnType;
        }
        else
            returnType = parseType(false);
        checkAdvance();

		preBeginFunction(name, signature, inputs, false, returnType);
		skipBlock();
		preEndFunction();
	}

	GrType parseAnonymousFunction(bool isTask) {
		dstring[] inputs;
		GrType returnType = GrBaseType.VoidType;
		GrType[] signature = parseSignature(inputs);

		if(!isTask) {
			//Return Type.
            returnType = parseType(false);
			checkAdvance();
		}

		preBeginFunction("$anon"d, signature, inputs, isTask, returnType, true);

        openDeferrableSection();
		parseBlock();
		addReturn();
        closeDeferrableSection();
        registerDeferBlocks();

		endFunction();

        GrType functionType = isTask ? GrBaseType.TaskType : GrBaseType.FunctionType;
        functionType.mangledType = grMangleNamedFunction("", signature);
        functionType.mangledReturnType = grMangleNamedFunction("", [returnType]);

        return functionType;
	}

	void parseBlock() {
        bool isMultiline;
		if(get().type == GrLexemeType.LeftCurlyBrace) {
            isMultiline = true;
            if(!checkAdvance())
			    logError("Unexpected end of file");
        }
		openBlock();

		void parseStatement() {
            switch(get().type) with(GrLexemeType) {
            case Semicolon:
            case RightCurlyBrace:
                advance();
                break;
            case Defer:
                parseDeferStatement();
                break;
            case If:
            case Unless:
                parseIfStatement();
                break;
            case While:
                parseWhileStatement();
                break;
            case Do:
                parseDoWhileStatement();
                break;
            case For:
                parseForStatement();
                break;
            case Loop:
                parseLoopStatement();
                break;
            case Raise:
                parseRaiseStatement();
                break;
            case Try:
                parseExceptionHandler();
                break;
            case Return:
                parseReturnStatement();
                break;
            case Kill:
                parseKill();
                break;
            case Yield:
                parseYield();
                break;
            case Continue:
                parseContinue();
                break;
            case Break:
                parseBreak();
                break;
            case VoidType: .. case AutoType:
                if(isDeclaration())
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            case Identifier:
                if(grIsStructure(get().svalue) || grIsUserType(get().svalue))
                    parseLocalDeclaration();
                else
                    goto default;
                break;
            default:
                parseExpression();
                break;
            }
        }

        if(isMultiline) {
            while(!isEnd()) {
                if(get().type == GrLexemeType.RightCurlyBrace)
                    break;
                parseStatement();
            }
        }
        else {
            parseStatement();
        }

        if(isMultiline) {
            if(get().type != GrLexemeType.RightCurlyBrace)
                logError("Missing symbol", "A block should always end with \'}\'");
        }
		closeBlock();
		checkAdvance();
	}

    bool isDeclaration() {
        const auto tempPos = current;
        if(get().type != GrLexemeType.AutoType)
            parseType();
        checkAdvance();
        bool isDecl;
        if(get().type == GrLexemeType.Identifier)
            isDecl = true;
        current = tempPos;
        return isDecl;
    }

	void skipBlock() {
		bool isMultiline;
		if(get().type == GrLexemeType.LeftCurlyBrace) {
            isMultiline = true;
            if(!checkAdvance())
			    logError("Unexpected end of file");
        }
		openBlock();

		void skipStatement() {
            switch(get().type) with(GrLexemeType) {
			case LeftCurlyBrace:
				skipBlock();
				break;
			default:
				checkAdvance();
				break;
			}
        }
		
		if(isMultiline) {
            while(!isEnd()) {
                if(get().type == GrLexemeType.RightCurlyBrace)
                    break;
                skipStatement();
            }
        }
        else {
            while(!isEnd()) {
                if(get().type == GrLexemeType.Semicolon)
                    break;
                skipStatement();
            }
        }

        if(isMultiline) {
            if(get().type != GrLexemeType.RightCurlyBrace)
                logError("Missing symbol", "A block should always end with \'}\'");
        }
		closeBlock();
		checkAdvance();
	}

    void parseKill() {
		addKill();
        advance();                    
    }

    void parseYield() {
		addInstruction(GrOpcode.Yield, 0u);
        advance();                    
    }

    //Exception handling
    void parseRaiseStatement() {
        advance();
        GrType type = parseSubExpression(false);
        convertType(type, grString);
        addInstruction(GrOpcode.Raise);
        checkDeferStatement();
    }

    void parseExceptionHandler() {
        advance();

        const auto tryPosition = currentFunction.instructions.length;
        addInstruction(GrOpcode.Try);

        parseBlock();

        if(get().type != GrLexemeType.Catch)
            logError("Missing catch", "A try must be followed by a catch statement");
        advance();

        if(get().type != GrLexemeType.LeftParenthesis)
            logError("Missing (", "");
        advance();

        if(get().type != GrLexemeType.Identifier)
            logError("Missing identifier", "");
        GrVariable errVariable = registerLocalVariable(get().svalue, grString);

        advance();
        if(get().type != GrLexemeType.RightParenthesis)
            logError("Missing )", "");
        advance();

        const auto catchPosition = currentFunction.instructions.length;
        addInstruction(GrOpcode.Catch);

        addInstruction(GrOpcode.GlobalPop_String);
        addSetInstruction(errVariable, grString);

        parseBlock();

        const auto endPosition = currentFunction.instructions.length;


        setInstruction(GrOpcode.Try, cast(uint)tryPosition, cast(uint)(catchPosition - tryPosition), true);
        setInstruction(GrOpcode.Catch, cast(uint)catchPosition, cast(uint)(endPosition - catchPosition), true);
    }

    //Defer
    void openDeferrableSection() {
        auto deferrableSection = new GrDeferrableSection;
        deferrableSection.deferInitPositions = cast(uint)currentFunction.instructions.length;
        currentFunction.deferrableSections ~= deferrableSection;

        currentFunction.isDeferrableSectionLocked.length ++;
    }

    int zaeaze = 0;
    void closeDeferrableSection() {
        if(!currentFunction.deferrableSections.length)
            logError("Deferrable section error", "A deferrable section had a mismatch");

        foreach(deferBlock; currentFunction.deferrableSections[$ - 1].deferredBlocks) {
            currentFunction.registeredDeferBlocks ~= deferBlock;
        }

        currentFunction.deferrableSections.length --;
        currentFunction.isDeferrableSectionLocked.length --;
    }

    void parseDeferStatement() {
        if(currentFunction.isDeferrableSectionLocked[$ - 1])
            logError("Invalid instruction", "You cannot use a defer statement inside another defer");
        advance();

        //Register the position of the block for a late parsing.
        GrDeferBlock deferBlock = new GrDeferBlock;
        deferBlock.position = cast(uint)currentFunction.instructions.length;
        deferBlock.parsePosition = current;
        deferBlock.scopeLevel = scopeLevel;
        currentFunction.deferrableSections[$ - 1].deferredBlocks ~= deferBlock;

        addInstruction(GrOpcode.Defer);

        //Parse the deferred block at the end of the outer block.
        skipBlock();
    }
    
    void checkDeferStatement() {
        if(currentFunction.isDeferrableSectionLocked[$ - 1])
            logError("Invalid instruction", "You cannot use a flow-control statement in a defer");
    }

    void registerDeferBlocks() {
        const auto tempParsePosition = current;
        const auto startDeferPos = cast(uint)currentFunction.instructions.length;
        
        int tempScopeLevel = scopeLevel;
        while(currentFunction.registeredDeferBlocks.length) {
            GrDeferBlock deferBlock = currentFunction.registeredDeferBlocks[0];
            currentFunction.registeredDeferBlocks = currentFunction.registeredDeferBlocks[1 .. $];

            setInstruction(GrOpcode.Defer, deferBlock.position, cast(int)(currentFunction.instructions.length - deferBlock.position), true);
            current = deferBlock.parsePosition;
            scopeLevel = deferBlock.scopeLevel;

            currentFunction.isDeferrableSectionLocked[$ - 1] = true;
            parseBlock();
            currentFunction.isDeferrableSectionLocked[$ - 1] = false;

            addInstruction(GrOpcode.Unwind);
        }
        currentFunction.registeredDeferBlocks.length = 0;
        current = tempParsePosition;
        scopeLevel = tempScopeLevel;
    }

	//Break
	void openBreakableSection() {
		breaksJumps ~= [null];
	}

	void closeBreakableSection() {
		if(!breaksJumps.length)
			logError("Breakable section error", "A breakable section had a mismatch");

		uint[] breaks = breaksJumps[$ - 1];
		breaksJumps.length --;

		foreach(position; breaks)
			setInstruction(GrOpcode.Jump, position, cast(int)(currentFunction.instructions.length - position), true);
	}

	void parseBreak() {
		if(!breaksJumps.length)
			logError("Non breakable statement", "The break statement is not inside a breakable statement");

        checkDeferStatement();
		breaksJumps[$ - 1] ~= cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.Jump);
		advance();
	}

	//Continue
	void openContinuableSection() {
		continuesJumps ~= [null];
	}

	void closeContinuableSection() {
		if(!continuesJumps.length)
			logError("Continuable section error", "A continuable section had a mismatch");

		uint[] continues = continuesJumps[$ - 1];
		uint destination = continuesDestinations[$ - 1];
		continuesJumps.length --;
		continuesDestinations.length --;

		foreach(position; continues)
			setInstruction(GrOpcode.Jump, position, cast(int)(position - destination), true);
	}

	void setContinuableSectionDestination() {
		continuesDestinations ~= cast(uint)currentFunction.instructions.length;
	}

	void parseContinue() {
		if(!continuesJumps.length)
			logError("Non continuable statement", "The continue statement is not inside a continuable statement");

        checkDeferStatement();
		continuesJumps[$ - 1] ~= cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.Jump);
		advance();
	}

    void parseGlobalDeclaration() {
        //GrVariable type
        GrType type = GrBaseType.VoidType;
        bool isAuto;
        if(get().type == GrLexemeType.AutoType)
            isAuto = true;
        else
            type = parseType();
        checkAdvance();

        //Identifier
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");

		dstring identifier = get().svalue;

        //Registering
		GrVariable variable = registerGlobalVariable(identifier, type);
        variable.isAuto = isAuto;

        //A structure does not need to be initialized.
        if(variable.type == GrBaseType.StructType)
            variable.isInitialized = true;
		
		checkAdvance();
		switch(get().type) with(GrLexemeType) {
		case Assign:
			checkAdvance();
			GrType expressionType = parseSubExpression(false);
			addSetInstruction(variable, expressionType);

            if(get().type != GrLexemeType.Semicolon)
                logError("Missing semicolon", "An expression must be finished with a ;");
            advance();
			break;
		case Semicolon:
            if(isAuto)
			    logError("Uninitialized auto-inferred global variable", "A global let type must be assigned at declaration");
            checkAdvance();
			break;
		default:
			logError("Invalid symbol", "A declaration must either be terminated by a ; or assigned with =");
		}
    }

	//Type Identifier [= EXPRESSION] ;
	void parseLocalDeclaration() {
        //GrVariable type
        GrType type = GrBaseType.VoidType;
        bool isAuto;
        if(get().type == GrLexemeType.AutoType)
            isAuto = true;
        else
            type = parseType();
        checkAdvance();

        //Identifier
		if(get().type != GrLexemeType.Identifier)
			logError("Missing identifier", "Expected a name such as \'foo\'");

		dstring identifier = get().svalue;

        //Registering
		GrVariable variable = registerLocalVariable(identifier, type);
        variable.isAuto = isAuto;

        //A structure does not need to be initialized.
        if(variable.type == GrBaseType.StructType)
            variable.isInitialized = true;
		
		checkAdvance();
		switch(get().type) with(GrLexemeType) {
		case Assign:
			checkAdvance();
			GrType expressionType = parseSubExpression(false);
			addSetInstruction(variable, expressionType);
			break;
		case Semicolon:
			break;
		default:
			logError("Invalid symbol", "A declaration must either be terminated by a ; or assigned with =");
		}
	}

    GrType parseFunctionReturnType() {
        GrType returnType = GrBaseType.VoidType;
        if(get().isType) {
            switch(get().type) with(GrLexemeType) {
            case IntType:
                returnType = GrType(GrBaseType.IntType);
                break;
            case FloatType:
                returnType = GrType(GrBaseType.FloatType);
                break;
            case BoolType:
                returnType = GrType(GrBaseType.BoolType);
                break;
            case StringType:
                returnType = GrType(GrBaseType.StringType);
                break;
            case ObjectType:
                returnType = GrType(GrBaseType.ObjectType);
                break;
            case ArrayType:
                returnType = GrType(GrBaseType.ArrayType);
                break;
            case DynamicType:
                returnType = GrType(GrBaseType.DynamicType);
                break;
            case FunctionType:
                GrType type = GrBaseType.FunctionType;
                dstring[] temp; 
                type.mangledType = grMangleNamedFunction("", parseSignature(temp, true));
                returnType = type;
                break;
            case TaskType:
                GrType type = GrBaseType.TaskType;
                dstring[] temp; 
                type.mangledType = grMangleNamedFunction("", parseSignature(temp, true));
                returnType = type;
                break;
            default:
                logError("Invalid type", "A " ~ to!string(get().type) ~ " is not a valid return type");
            }

            checkAdvance();
        }

        return returnType;
    }

	void parseIfStatement() {
        bool isNegative = get().type == GrLexemeType.Unless;
		advance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		advance();
		parseSubExpression();
		advance();

		uint jumpPosition = cast(uint)currentFunction.instructions.length;
        //Jumps to if(0) for "if", if(!= 0) for "unless".
		addInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual);

		parseBlock(); //{ .. }

		//If(1){}, jumps out.
		uint[] exitJumps;
		exitJumps ~= cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.Jump);

		//Jumps to if(0) for "if", if(!= 0) for "unless".
		setInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual,
            jumpPosition,
            cast(int)(currentFunction.instructions.length - jumpPosition),
            true);

		bool isElseIf;
		do {
			isElseIf = false;
			if(get().type == GrLexemeType.Else) {
				checkAdvance();
				if(get().type == GrLexemeType.If || get().type == GrLexemeType.Unless) {
                    isNegative = get().type == GrLexemeType.Unless;
					isElseIf = true;
					checkAdvance();
					if(get().type != GrLexemeType.LeftParenthesis)
						logError("Missing symbol", "A condition should always start with \'(\'");
					checkAdvance();

					parseSubExpression();
                    advance();

					jumpPosition = cast(uint)currentFunction.instructions.length;
					//Jumps to if(0) for "if", if(!= 0) for "unless".
		            addInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual);

					parseBlock(); //{ .. }

					//If(1){}, jumps out.
					exitJumps ~= cast(uint)currentFunction.instructions.length;
					addInstruction(GrOpcode.Jump);

					//Jumps to if(0) for "if", if(!= 0) for "unless".
					setInstruction(isNegative ? GrOpcode.JumpNotEqual : GrOpcode.JumpEqual,
                        jumpPosition,
                        cast(int)(currentFunction.instructions.length - jumpPosition),
                        true);
				}
				else
					parseBlock();
			}
		}
		while(isElseIf);

		foreach(uint position; exitJumps)
			setInstruction(GrOpcode.Jump, position, cast(int)(currentFunction.instructions.length - position), true);
	}

	void parseWhileStatement() {
		advance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		/* While is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		/* Continue jump. */
		setContinuableSectionDestination();

		uint conditionPosition,
			blockPosition = cast(uint)currentFunction.instructions.length;

		advance();
		parseSubExpression();

		advance();
		conditionPosition = cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.JumpEqual);

		parseBlock();

		addInstruction(GrOpcode.Jump, cast(int)(blockPosition - currentFunction.instructions.length), true);
		setInstruction(GrOpcode.JumpEqual, conditionPosition, cast(int)(currentFunction.instructions.length - conditionPosition), true);

		/* While is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

	void parseDoWhileStatement() {
		advance();

		/* While is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		uint blockPosition = cast(uint)currentFunction.instructions.length;

		parseBlock();
		if(get().type != GrLexemeType.While)
			logError("Missing while", "A do-while statement expects the keyword while after \'}\'");
		advance();

		/* Continue jump. */
		setContinuableSectionDestination();

		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		advance();
		parseSubExpression();
		advance();

		addInstruction(GrOpcode.JumpNotEqual, cast(int)(blockPosition - currentFunction.instructions.length), true);

		/* While is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

	void parseForStatement() {
		advance();
		if(get().type != GrLexemeType.LeftParenthesis)
			logError("Missing symbol", "A condition should always start with \'(\'");

		advance();
		GrLexeme identifier = get();
		if(identifier.type != GrLexemeType.Identifier)
			logError("Missing identifier", "For syntax: for(identifier, array) {}");
		GrVariable variable = getVariable(identifier.svalue);
		 
		advance();
		if(get().type != GrLexemeType.Comma)
			logError("Missing symbol", "Did you forget the \',\' ?");
		advance();

		/* Init */
		GrVariable iterator = registerSpecialVariable("iterator"d ~ to!dstring(scopeLevel), GrType(GrBaseType.IntType));
		GrVariable index = registerSpecialVariable("index"d ~ to!dstring(scopeLevel), GrType(GrBaseType.IntType));
		GrVariable array = registerSpecialVariable("array"d ~ to!dstring(scopeLevel), GrType(GrBaseType.ArrayType));
		
		//From length to 0
		GrType arrayType = parseSubExpression();
		addSetInstruction(array, GrType(GrBaseType.VoidType), true);
		addInstruction(GrOpcode.Length_Array);
		addInstruction(GrOpcode.SetupIterator);		
		addSetInstruction(iterator);

		//Set index to -1
		addIntConstant(-1);
		addSetInstruction(index);

		/* For is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		/* Continue jump. */
		setContinuableSectionDestination();


		advance();
		uint blockPosition = cast(uint)currentFunction.instructions.length;

		addGetInstruction(iterator, GrType(GrBaseType.IntType));
		addInstruction(GrOpcode.DecrementInt);
		addSetInstruction(iterator);

		addGetInstruction(iterator, GrType(GrBaseType.IntType));
		uint jumpPosition = cast(uint)currentFunction.instructions.length;
		addInstruction(GrOpcode.JumpEqual);

		//Set Index
		addGetInstruction(array);
		addGetInstruction(index);
		addInstruction(GrOpcode.IncrementInt);
		addSetInstruction(index, GrType(GrBaseType.VoidType), true);
		addInstruction(GrOpcode.Index_Array);
		convertType(GrType(GrBaseType.DynamicType), variable.type);
		addSetInstruction(variable);

		parseBlock();

		addInstruction(GrOpcode.Jump, cast(int)(blockPosition - currentFunction.instructions.length), true);
		setInstruction(GrOpcode.JumpEqual, jumpPosition, cast(int)(currentFunction.instructions.length - jumpPosition), true);

		/* For is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

	void parseLoopStatement() {
        bool isInfinite;
        GrVariable iterator;
        
		advance();
		if(get().type == GrLexemeType.LeftParenthesis) {
            advance();

            /* Init */
            iterator = registerSpecialVariable("iterator"d ~ to!dstring(scopeLevel), GrType(GrBaseType.IntType));
        
            //Init counter
            GrType type = parseSubExpression();
    		advance();

            convertType(type, GrType(GrBaseType.IntType));
            addInstruction(GrOpcode.SetupIterator);
            addSetInstruction(iterator);
        }
        else
            isInfinite = true;

		/* For is breakable and continuable. */
		openBreakableSection();
		openContinuableSection();

		/* Continue jump. */
		setContinuableSectionDestination();


		uint blockPosition = cast(uint)currentFunction.instructions.length;
        uint jumpPosition;

        if(!isInfinite) {
            addGetInstruction(iterator, GrType(GrBaseType.IntType));
            addInstruction(GrOpcode.DecrementInt);
            addSetInstruction(iterator);

            addGetInstruction(iterator, GrType(GrBaseType.IntType));
            jumpPosition = cast(uint)currentFunction.instructions.length;
            addInstruction(GrOpcode.JumpEqual);
        }

		parseBlock();

		addInstruction(GrOpcode.Jump, cast(int)(blockPosition - currentFunction.instructions.length), true);
		if(!isInfinite)
            setInstruction(GrOpcode.JumpEqual, jumpPosition, cast(int)(currentFunction.instructions.length - jumpPosition), true);

		/* For is breakable and continuable. */
		closeBreakableSection();
		closeContinuableSection();
	}

	void parseReturnStatement() {
		checkAdvance();
        if(currentFunction.name == "main") {
            addKill();            
        }
        else if(currentFunction.returnType == GrType(GrBaseType.VoidType)) {
            addReturn();
        }
        else {
            GrType returnedType = parseSubExpression(false);
            addReturn();
            if(returnedType != currentFunction.returnType)
                logError("Invalid return type", "The returned type \'" ~ to!string(returnedType) ~ "\' does not match the function definition \'" ~ to!string(currentFunction.returnType) ~ "\'");

        }
	}

    void addReturn() {
        checkDeferStatement();
        addInstruction(GrOpcode.Return);
    }

    void addKill() {
        checkDeferStatement();
        addInstruction(GrOpcode.Kill);
    }

    uint getLeftOperatorPriority(GrLexemeType type) {
		switch(type) with(GrLexemeType) {
        case Assign: .. case PowerAssign:
            return 6;
        case Or:
            return 1;
        case Xor:
            return 2;
        case And:
            return 3;
        case Equal: .. case NotEqual:
            return 14;
        case GreaterOrEqual: .. case Lesser:
            return 15;
        case Add: .. case Substract:
            return 16;
        case Multiply: .. case Remainder:
            return 17;
        case Power:
            return 18;
        case Not:
        case Plus:
        case Minus:
        case Increment:
        case Decrement:
            return 19;
        default:
            logError("Unknown priority", "The operator is not listed in the operator priority table");
            return 0;
		}
	}

	uint getRightOperatorPriority(GrLexemeType type) {
		switch(type) with(GrLexemeType) {
        case Assign: .. case PowerAssign:
            return 20;
        case Or:
            return 1;
        case Xor:
            return 2;
        case And:
            return 3;
        case Equal: .. case NotEqual:
            return 4;
        case GreaterOrEqual: .. case Lesser:
            return 5;
        case Add: .. case Substract:
            return 16;
        case Multiply: .. case Remainder:
            return 17;
        case Power:
            return 18;
        case Not:
        case Plus:
        case Minus:
        case Increment:
        case Decrement:
            return 19;
        default:
            logError("Unknown priority", "The operator is not listed in the operator priority table");
            return 0;
		}
	}

	GrType convertType(GrType src, GrType dst, bool noFail = false, bool isExplicit = false) {
        if(src.baseType == dst.baseType) {
            switch(src.baseType) with(GrBaseType) {
            case FunctionType:
                if(src.mangledType == dst.mangledType && src.mangledReturnType == dst.mangledReturnType)
                    return dst;
                break;
            case TaskType:
                if(src.mangledType == dst.mangledType && src.mangledReturnType == dst.mangledReturnType)
                    return dst;
                break;
            case BoolType:
            case IntType:
            case FloatType:
            case StringType:
            case DynamicType:
            case ArrayType:
                return dst;
            case StructType:
            case UserType:
                if(dst.mangledType == src.mangledType)
                    return dst;
                break;
            default:
                break;
            }
        }
		
        //User-defined conversions.
        if(addCustomConversion(src, dst, isExplicit) == dst)
            return dst;

        if(!noFail)
		    logError("Incompatible types", "Cannot convert \'"
                ~ grGetPrettyType(src) ~ "\' to \'" ~ grGetPrettyType(dst) ~ "\'");
		return GrType(GrBaseType.VoidType);	
	}

    GrType addCustomConversion(GrType leftType, GrType rightType, bool isExplicit) {
        GrType resultType = GrBaseType.VoidType;

        //As opposed to other functions, we need the return type (rightType) to be part of the signature.
        dstring mangledName = grMangleNamedFunction("@as", [leftType, rightType]);
        
        //GrPrimitive check
        if(grIsPrimitiveDeclared(mangledName)) {
            GrPrimitive primitive = grGetPrimitive(mangledName);
            //Some implicit conversions are disabled.
            //ex: float -> int because we might lose information.
            if(primitive.isExplicit && !isExplicit)
                return resultType;
            addInstruction(GrOpcode.PrimitiveCall, primitive.index);
            resultType = primitive.returnType;
        }

        //GrFunction check
        if(resultType.baseType == GrBaseType.VoidType) {
    		auto func = (mangledName in functions);
            if(func !is null) {
                resultType = addFunctionCall(mangledName);
            }
        }

        return resultType;     
    }

    void parseArrayBuilder() {
        if(get().type != GrLexemeType.LeftBracket)
            logError("Missing [", "Missing [");
        advance();

        int arraySize;
        while(get().type != GrLexemeType.RightBracket) {
            convertType(parseSubExpression(), grDynamic);
            arraySize ++;

            if(get().type == GrLexemeType.RightBracket)
                break;
            if(get().type != GrLexemeType.Comma)
                logError("Missing comma or ]", "bottom text");
            checkAdvance();
        }

        addInstruction(GrOpcode.Build_Array, arraySize);
        advance();
    }

    void parseArrayIndex(bool asRefType) {
        if(get().type != GrLexemeType.LeftBracket)
            logError("Missing [", "Missing [");
        advance();

        for(;;) {
            if(get().type == GrLexemeType.Comma)
                logError("Missing value", "bottom text");
            auto index = parseSubExpression();
            if(index.baseType == GrBaseType.VoidType)
                logError("Syntax Error", "right there");
            convertType(index, grInt);

            if(get().type == GrLexemeType.RightBracket) {
                addInstruction(asRefType ? GrOpcode.IndexRef_Array : GrOpcode.Index_Array);
                break;
            }
            if(get().type != GrLexemeType.Comma)
                logError("Missing comma or ]", "bottom text");
            checkAdvance();
            if(get().type == GrLexemeType.RightBracket)
                logError("Missing comma or ]", "bottom text");

            addInstruction(asRefType ? GrOpcode.IndexRef_Array : GrOpcode.Index_Array);
            asRefType = true;
        }

        advance();
    }

    GrType parseStructureField(GrType type) {
        dstring fieldName;
        GrType fieldType = GrBaseType.VoidType;

        advance();
        if(type.baseType != GrBaseType.StructType)
            logError("Invalid type", "Cannot access struct field");
        if(get().type != GrLexemeType.Identifier)
            logError("Missing struct field", "Missing struct field");
        fieldName = get().svalue;
        advance();
        auto structure = grGetStructure(type.mangledType);
        const auto nbFields = structure.fields.length;
        for(int i = 1; i <= structure.fields.length; i ++) {
            if(fieldName == structure.fields[nbFields - i]) {
                fieldType = structure.signature[nbFields - i];
                addGlobalPush(fieldType, 1u);
            }
            else
                decreaseStack(structure.signature[nbFields - i], 1);
        }
        addGlobalPop(fieldType);
        return fieldType;
    }

    GrType parseConversionOperator(GrType[] typeStack) {
        if(!typeStack.length)
            logError("Conversion Error", "You can only convert a value");
        advance();
        auto asType = parseType();
        checkAdvance();
        convertType(typeStack[$ - 1], asType, false, true);
        typeStack[$ - 1] = asType;
        return asType;
    }

	void parseExpression(GrType currentType = GrBaseType.VoidType) {
		GrVariable[] lvalues;
		GrLexemeType[] operatorsStack;
		GrType[] typeStack;
        GrType lastType = currentType;
		bool isReturningValue = false,
			hasValue = false, hadValue = false,
            hasLValue = false, hadLValue = false,
            hasReference = false, hadReference = false,
			isRightUnaryOperator = true, isEndOfExpression = false;

		if(lastType != GrType(GrBaseType.VoidType))
			isReturningValue = true;

		do {
			if(hasValue && currentType != lastType && lastType != GrType(GrBaseType.VoidType)) {
                lastType = currentType;
				currentType = lastType;
			}
            else
                lastType = currentType;

			isRightUnaryOperator = false;
			hadValue = hasValue;
			hasValue = false;

			hadLValue = hasLValue;
			hasLValue = false;

            hadReference = hasReference;
            hasReference = false;

			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
			case Comma:
			case Semicolon:
			case RightParenthesis:
				isEndOfExpression = true;
				break;
			case LeftParenthesis:
                if(hadValue) {
                    currentType = parseAnonymousCall(typeStack[$ - 1]);
                    if(currentType.baseType == GrBaseType.VoidType) {
                        typeStack.length --;
                    }
                    else {
                        hadValue = false;
                        hasValue = true;
                        typeStack[$ - 1] = currentType;
                    }
                }
                else {
                    advance();
                    currentType = parseSubExpression();
                    advance();
                    hasValue = true;
                    typeStack ~= currentType;
                }
				break;
            case LeftBracket:
                //Index
                if(hadValue) {
                    hadValue = false;
                    currentType = GrType(GrBaseType.DynamicType);
                    lastType = GrType(GrBaseType.DynamicType);
                    parseArrayIndex(hadReference);
                    //Check if there is an assignement or not, discard if it's only a rvalue
                    const auto nextLexeme = get();
                    if(requireLValue(nextLexeme.type)) {
                        hasLValue = true;
                        lvalues ~= null;
                    }
                    typeStack[$ - 1] = currentType;
                }
                //Build new array
                else {
                    currentType = GrType(GrBaseType.ArrayType);
                    parseArrayBuilder();
                    typeStack ~= currentType;
                }
                hasValue = true;
                break;
            case Period:
                currentType = parseStructureField(currentType);
                lastType = currentType;
                hadValue = false;
                hasValue = true;
                typeStack[$ - 1] = currentType;                
                break;
			case Integer:
				currentType = GrType(GrBaseType.IntType);
				addIntConstant(lex.ivalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case Float:
				currentType = GrType(GrBaseType.FloatType);
				addFloatConstant(lex.fvalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case Boolean:
				currentType = GrType(GrBaseType.BoolType);
				addBoolConstant(lex.bvalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case String:
				currentType = GrType(GrBaseType.StringType);
				addStringConstant(lex.svalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
            case Pointer:
                currentType = parseFunctionPointer(currentType);
                hasValue = true;
                typeStack ~= currentType;
                break;
            case As:
                if(!hadValue)
                    logError("","");
                currentType = parseConversionOperator(typeStack);
                hasValue = true;
                hadValue = false;
                break;
			case FunctionType:
				currentType = parseAnonymousFunction(false);
				hasValue = true;
                typeStack ~= currentType;
				break;
			case TaskType:
				currentType = parseAnonymousFunction(true);
				hasValue = true;
                typeStack ~= currentType;
				break;
			case Assign: .. case PowerAssign:
				if(!hadLValue)
					logError("Expression invalid", "Missing lvalue in expression");
				hadLValue = false;
				goto case Multiply;
			case Add:
				if(!hadValue)
					lex.type = GrLexemeType.Plus;
				goto case Multiply;
			case Substract:
				if(!hadValue)
					lex.type = GrLexemeType.Minus;
				goto case Multiply;
			case Increment: .. case Decrement:
				isRightUnaryOperator = true;
				goto case Multiply;
			case Multiply: .. case Xor:
				if(!hadValue && lex.type != GrLexemeType.Plus && lex.type != GrLexemeType.Minus && lex.type != GrLexemeType.Not)
					logError("Expected value", "A value is missing");

				while(operatorsStack.length && getLeftOperatorPriority(operatorsStack[$ - 1]) > getRightOperatorPriority(lex.type)) {
					GrLexemeType operator = operatorsStack[$ - 1];
					switch(operator) with(GrLexemeType) {
					case Assign:
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					case AddAssign: .. case PowerAssign:
						currentType = addOperator(operator - (GrLexemeType.AddAssign - GrLexemeType.Add), typeStack);
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					case Increment: .. case Decrement:
						currentType = addOperator(operator, typeStack);
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					default:
						currentType = addOperator(operator, typeStack);
						break;
					}
					
					operatorsStack.length --;
				}

				operatorsStack ~= lex.type;
				if(hadValue && isRightUnaryOperator) {
					hasValue = true;
					hadValue = false;
				}
				else
					hasValue = false;
				checkAdvance();
				break;
			case Identifier:
				GrVariable lvalue;
				currentType = parseIdentifier(lvalue, lastType);
				
                //Check if there is an assignement or not, discard if it's only a rvalue
                const auto nextLexeme = get();
				if(lvalue !is null && requireLValue(nextLexeme.type)) {
					hasLValue = true;
					lvalues ~= lvalue;

                    if(lvalue.isAuto)
                        hasValue = true;
				}

                if(!hasLValue && nextLexeme.type == GrLexemeType.LeftBracket)
                    hasReference = true;

				if(currentType != GrType(GrBaseType.VoidType)) {
					hasValue = true;
                    typeStack ~= currentType;
                }
				break;
			default:
				logError("Unexpected symbol", "Invalid \'" ~ to!string(lex.type) ~ "\' symbol in the expression");
			}

			if(hasValue && hadValue)
				logError("Missing symbol", "The expression is not terminated by a \';\'");
		}
		while(!isEndOfExpression);

		if(operatorsStack.length) {
			if(!hadValue) {
				if(!isRightUnaryOperator)
					logError("Expected value", "A value is missing");
				else
					logError("Expected value", "A value is missing");
			}
		}

		while(operatorsStack.length) {
			GrLexemeType operator = operatorsStack[$ - 1];

			switch(operator) with(GrLexemeType) {
			case Assign:
                if(operatorsStack.length == 1 && !isReturningValue) {
				    addSetInstruction(lvalues[$ - 1], currentType, false);
                    currentType = GrType(GrBaseType.VoidType);
                }
                else {
				    addSetInstruction(lvalues[$ - 1], currentType, true);
                }
				lvalues.length --;
				break;
			case AddAssign: .. case PowerAssign:
				currentType = addOperator(operator - (GrLexemeType.AddAssign - GrLexemeType.Add), typeStack);
				if(operatorsStack.length == 1 && !isReturningValue) {
				    addSetInstruction(lvalues[$ - 1], currentType, false);
                    currentType = GrType(GrBaseType.VoidType);
                }
                else {
				    addSetInstruction(lvalues[$ - 1], currentType, true);
                }			
				lvalues.length --;
				break;
			case Increment: .. case Decrement:
				currentType = addOperator(operator, typeStack);
				if(operatorsStack.length == 1 && !isReturningValue) {
				    addSetInstruction(lvalues[$ - 1], currentType, false);
                    currentType = GrType(GrBaseType.VoidType);
                }
                else {
				    addSetInstruction(lvalues[$ - 1], currentType, true);
                }	
				lvalues.length --;
				break;
			default:
				currentType = addOperator(operator, typeStack);
				break;
			}
			operatorsStack.length --;
		}

		if(currentType != GrType(GrBaseType.VoidType) && !isReturningValue)
			decreaseStack(currentType, 1u);
	}

    void decreaseStack(GrType type, ushort count) {
        final switch(type.baseType) with(GrBaseType) {
        case IntType:
        case BoolType:
        case FunctionType:
        case TaskType:
            addInstruction(GrOpcode.PopStack_Int, count);
            break;
        case FloatType:
            addInstruction(GrOpcode.PopStack_Float, count);
            break;
        case StringType:
            addInstruction(GrOpcode.PopStack_String, count);
            break;
        case ArrayType:
            addInstruction(GrOpcode.PopStack_Array, count);
            break;
        case DynamicType:
            addInstruction(GrOpcode.PopStack_Any, count);
            break;
        case ObjectType:
            addInstruction(GrOpcode.PopStack_Object, count);
            break;
        case UserType:
            addInstruction(GrOpcode.PopStack_UserData, count);
            break;
        case StructType:
            throw new Exception("Cannot decrease the stack for a void type");
        case VoidType:
            throw new Exception("Cannot decrease the stack for a struct type");
        }
    }

    bool requireLValue(GrLexemeType operatorType) {
        switch(operatorType) with(GrLexemeType) {
        case Increment:
        case Decrement:
        case Assign: .. case PowerAssign:
            return true;
        default:
            return false;
        }
    }

    GrType parseFunctionPointer(GrType currentType) {
        checkAdvance();
        if(get().type == GrLexemeType.LeftParenthesis) {
            checkAdvance();
            GrType refType = parseType();
            checkAdvance();
            if(get().type != GrLexemeType.RightParenthesis)
                logError("Missing symbol", "Expected a \')\' after the type");
            checkAdvance();
            if(currentType.baseType == GrBaseType.VoidType)
                currentType = refType;
            else
                currentType = convertType(refType, currentType);
        }
        if(get().type != GrLexemeType.Identifier)
            logError("GrFunction name expected", "The name of the func or task is required after \'&\'");
        if(currentType.baseType != GrBaseType.FunctionType && currentType.baseType != GrBaseType.TaskType)
            logError("GrFunction ref error", "Cannot infer the type of \'" ~ to!string(get().svalue) ~ "\'");

        GrType funcType = addFunctionAddress(get().svalue ~ currentType.mangledType);
        convertType(funcType, currentType);
        checkAdvance();
        return currentType;
    }

	GrType parseSubExpression(bool useParenthesis = true) {
		GrVariable[] lvalues;
		GrLexemeType[] operatorsStack;
		GrType[] typeStack;
		GrType currentType = GrType(GrBaseType.VoidType), lastType = GrType(GrBaseType.VoidType);
		bool hasValue = false, hadValue = false,
        hasLValue = false, hadLValue = false,
        hasReference = false, hadReference = false,
		isRightUnaryOperator = true, isEndOfExpression = false;

		do {
			if(hasValue && currentType != lastType && lastType != GrType(GrBaseType.VoidType)) {
				lastType = currentType;//convertType(currentType, lastType);
				currentType = lastType;
			}
            else
                lastType = currentType;

			isRightUnaryOperator = false;
			hadValue = hasValue;
			hasValue = false;

			hadLValue = hasLValue;
			hasLValue = false;

            hadReference = hasReference;
            hasReference = false;

			GrLexeme lex = get();
			switch(lex.type) with(GrLexemeType) {
			case Semicolon:
				if(useParenthesis)
					logError("Unexpected symbol", "A \';\' cannot exist inside this expression");
				else
					isEndOfExpression = true;
				break;
			case Comma:
				if(useParenthesis)
					isEndOfExpression = true;
				else
					logError("Unexpected symbol", "A \',\' cannot exist inside this expression");
				break;
			case RightParenthesis:
				if(useParenthesis)
					isEndOfExpression = true;
				else
					logError("Unexpected symbol", "A \')\' cannot exist inside this expression");
				break;
            case RightBracket:
				if(useParenthesis)
					isEndOfExpression = true;
				else
					logError("Unexpected symbol", "A \']\' cannot exist inside this expression");
				break;
			case LeftParenthesis:
                if(hadValue) {
                    currentType = parseAnonymousCall(typeStack[$ - 1]);
                    if(currentType.baseType == GrBaseType.VoidType) {
                        typeStack.length --;
                    }
                    else {
                        hadValue = false;
                        hasValue = true;
                        typeStack[$ - 1] = currentType;
                    }
                }
                else {
                    advance();
                    currentType = parseSubExpression();
                    advance();
                    hasValue = true;
                    typeStack ~= currentType;
                }
                break;
            case LeftBracket:
                //Index
                if(hadValue) {
                    hadValue = false;
                    currentType = GrType(GrBaseType.DynamicType);
                    lastType = GrType(GrBaseType.DynamicType);
                    parseArrayIndex(hadReference);
                    //Check if there is an assignement or not, discard if it's only a rvalue
                    const auto nextLexeme = get();
                    if(requireLValue(nextLexeme.type)) {
                        hasLValue = true;
                        lvalues ~= null;
                    }
                    typeStack[$ - 1] = currentType;
                }
                //Build new array
                else {
                    currentType = GrType(GrBaseType.ArrayType);
                    parseArrayBuilder();
                    typeStack ~= currentType;
                }
                hasValue = true;
                break;
            case Period:
                currentType = parseStructureField(currentType);
                lastType = currentType;
                hadValue = false;
                hasValue = true;
                typeStack[$ - 1] = currentType;
                break;
			case Integer:
				currentType = GrType(GrBaseType.IntType);
				addIntConstant(lex.ivalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case Float:
				currentType = GrType(GrBaseType.FloatType);
				addFloatConstant(lex.fvalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case Boolean:
				currentType = GrType(GrBaseType.BoolType);
				addBoolConstant(lex.bvalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
			case String:
				currentType = GrType(GrBaseType.StringType);
				addStringConstant(lex.svalue);
				hasValue = true;
                typeStack ~= currentType;
				checkAdvance();
				break;
            case Pointer:
                currentType = parseFunctionPointer(currentType);
                typeStack ~= currentType;
                hasValue = true;
                break;
            case As:
                if(!hadValue)
                    logError("","");
                currentType = parseConversionOperator(typeStack);
                hasValue = true;
                hadValue = false;
                break;
			case FunctionType:
				currentType = parseAnonymousFunction(false);
                typeStack ~= currentType;
				hasValue = true;
				break;
			case TaskType:
				currentType = parseAnonymousFunction(true);
                typeStack ~= currentType;
				hasValue = true;
				break;
			case Assign: .. case PowerAssign:
				if(!hadLValue)
					logError("Expression invalid", "Missing lvalue in expression");
				hadLValue = false;
				goto case Multiply;
			case Add:
				if(!hadValue)
					lex.type = GrLexemeType.Plus;
				goto case Multiply;
			case Substract:
				if(!hadValue)
					lex.type = GrLexemeType.Minus;
				goto case Multiply;
			case Increment: .. case Decrement:
				isRightUnaryOperator = true;
				goto case Multiply;
			case Multiply: .. case Xor:
				if(!hadValue && lex.type != GrLexemeType.Plus && lex.type != GrLexemeType.Minus && lex.type != GrLexemeType.Not)
					logError("Expected value", "A value is missing");

				while(operatorsStack.length && getLeftOperatorPriority(operatorsStack[$ - 1]) > getRightOperatorPriority(lex.type)) {
					GrLexemeType operator = operatorsStack[$ - 1];
	
					switch(operator) with(GrLexemeType) {
					case Assign:
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					case AddAssign: .. case PowerAssign:
						currentType = addOperator(operator - (GrLexemeType.AddAssign - GrLexemeType.Add), typeStack);
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					case Increment: .. case Decrement:
						currentType = addOperator(operator, typeStack);
						addSetInstruction(lvalues[$ - 1], currentType, true);
						lvalues.length --;
						break;
					default:
						currentType = addOperator(operator, typeStack);
						break;
					}

					operatorsStack.length --;
				}

				operatorsStack ~= lex.type;
				if(hadValue && isRightUnaryOperator) {
					hasValue = true;
					hadValue = false;
				}
				else
					hasValue = false;
				checkAdvance();
				break;
			case Identifier:
				GrVariable lvalue;
				currentType = parseIdentifier(lvalue, lastType);

                //Check if there is an assignement or not, discard if it's only a rvalue
                const auto nextLexeme = get();
				if(lvalue !is null && requireLValue(nextLexeme.type)) {
					hasLValue = true;
					lvalues ~= lvalue;

                    if(lvalue.isAuto)
                        hasValue = true;
				}

                if(!hasLValue && nextLexeme.type == GrLexemeType.LeftBracket)
                    hasReference = true;

				if(currentType != GrType(GrBaseType.VoidType)) {
					hasValue = true;
                    typeStack ~= currentType;
                }
				break;
			default:
				logError("Unexpected symbol", "Invalid \'" ~ to!string(lex.type) ~ "\' symbol in the expression");
			}

			if(hasValue && hadValue)
				logError("Missing symbol", "The expression is not terminated by a \';\'");
		}
		while(!isEndOfExpression);

		if(operatorsStack.length) {
			if(!hadValue) {
				if(!isRightUnaryOperator)
					logError("Expected value", "A value is missing");
				else
					logError("Expected value", "A value is missing");
			}
		}

		while(operatorsStack.length) {
			GrLexemeType operator = operatorsStack[$ - 1];
	
			switch(operator) with(GrLexemeType) {
			case Assign:
				addSetInstruction(lvalues[$ - 1], currentType, true);
				lvalues.length --;
				break;
			case AddAssign: .. case PowerAssign:
				currentType = addOperator(operator - (GrLexemeType.AddAssign - GrLexemeType.Add), typeStack);
				addSetInstruction(lvalues[$ - 1], currentType, true);			
				lvalues.length --;
				break;
			case Increment: .. case Decrement:
				currentType = addOperator(operator, typeStack);
				addSetInstruction(lvalues[$ - 1], currentType, true);
				lvalues.length --;
				break;
			default:
				currentType = addOperator(operator, typeStack);
				break;
			}

			operatorsStack.length --;
		}
        
        return currentType;
	}

    GrType parseAnonymousCall(GrType type) {
        checkAdvance();
        //Signature parsing with type conversion
		GrType[] signature;
        GrType[] anonSignature = grUnmangleSignature(type.mangledType);
        int i;
        if(get().type != GrLexemeType.RightParenthesis) {
            for(;;) {
                if(i >= anonSignature.length)
                    logError("Invalid anonymous call", "The number of parameters does not match");
                GrType subType = parseSubExpression();
                signature ~= convertType(subType, anonSignature[i]);
                if(get().type == GrLexemeType.RightParenthesis)
                    break;
                advance();
                i ++;
            }
        }
        checkAdvance();

        //Push the values on the global stack for task spawning.
        if(type.baseType == GrBaseType.TaskType)
            addGlobalPush(signature);

        //Anonymous call.
        GrType retType = grUnmangle(type.mangledReturnType);

        if(type.baseType == GrBaseType.FunctionType)
            addInstruction(GrOpcode.AnonymousCall, 0u);
        else if(type.baseType == GrBaseType.TaskType)
            addInstruction(GrOpcode.AnonymousTask, 0u);
        else
            logError("Invalid anonymous type", "debug");
        return retType;
    }

	//Parse an identifier or function call and return the deduced return type and lvalue.
	GrType parseIdentifier(ref GrVariable variable, GrType expectedType = GrBaseType.VoidType) {
		GrType returnType = GrBaseType.VoidType;
		GrLexeme identifier = get();		
		bool isFunctionCall = false;
        dstring identifierName = identifier.svalue;

		advance();

        if(get().type == GrLexemeType.Period) {
			auto structVar = getVariable(identifier.svalue);
            if(structVar is null || structVar.type.baseType != GrBaseType.StructType)
                logError("Invalid symbol", "You can only access a field from a struct");
            else {
                do {
                    checkAdvance();
                    if(get().type != GrLexemeType.Identifier)
                        logError("Missing identifier", "A struct field must have a name");
                    identifierName ~= "." ~ get().svalue;
                    checkAdvance();
                }
                while(get().type == GrLexemeType.Period);
            }
        }

		if(get().type == GrLexemeType.LeftParenthesis)
			isFunctionCall = true;

		if(isFunctionCall) {
			GrType[] signature;
			advance();

			auto var = (identifierName in currentFunction.localVariables);
            if(var is null)
                var = (identifierName in globalVariables);
			if(var !is null) {
                //Signature parsing with type conversion
                GrType[] anonSignature = grUnmangleSignature(var.type.mangledType);
                int i;
                if(get().type != GrLexemeType.RightParenthesis) {
                    for(;;) {
                        if(i >= anonSignature.length)
                            logError("Invalid anonymous call", "The number of parameters does not match");
                        GrType subType = parseSubExpression();
                        signature ~= convertType(subType, anonSignature[i]);
                        if(get().type == GrLexemeType.RightParenthesis)
                            break;
                        advance();
                        i ++;
                    }
                }
                checkAdvance();

                //Push the values on the global stack for task spawning.
                if(var.type.baseType == GrBaseType.TaskType)
                    addGlobalPush(signature);

				//Anonymous call.
				bool hasAnonFunc = false;
				addGetInstruction(*var);
                
				returnType = grUnmangle(var.type.mangledReturnType);

				if(var.type.baseType == GrBaseType.FunctionType)
					addInstruction(GrOpcode.AnonymousCall, 0u);
				else if(var.type.baseType == GrBaseType.TaskType)
					addInstruction(GrOpcode.AnonymousTask, 0u);
				else
					logError("Invalid anonymous type", "debug");

				/*foreach(anonFunc; anonymousFunctions) {
					if(anonFunc.name == currentFunction.name) {

						hasAnonFunc = true;
						break;
					}
				}*/
			}
			else {
                //Signature parsing, no coercion is made
                if(get().type != GrLexemeType.RightParenthesis) {
                    for(;;) {
                        signature ~= parseSubExpression();
                        if(get().type == GrLexemeType.RightParenthesis)
                            break;
                        advance();
                    }
                }
                checkAdvance();

                //Mangling function name
				dstring mangledName = grMangleNamedFunction(identifierName, signature);
				
				//GrPrimitive call.
				if(grIsPrimitiveDeclared(mangledName)) {
					GrPrimitive primitive = grGetPrimitive(mangledName);
					addInstruction(GrOpcode.PrimitiveCall, primitive.index);
					returnType = primitive.returnType;
				}
				else //GrFunction/Task call.
					returnType = addFunctionCall(mangledName);
			}
		}
		else {
			//Declared variable.
			variable = getVariable(identifierName);
			returnType = variable.type;
            //If it's an assignement, we want the GET instruction to be after the assignement, not there.
            const auto nextLexeme = get();
            if(nextLexeme.type == GrLexemeType.LeftBracket) {
                addInstruction(GrOpcode.LocalLoad_Ref);
                returnType = GrType(GrBaseType.DynamicType);
            }
            else if(nextLexeme.type != GrLexemeType.Assign)
                addGetInstruction(variable, expectedType);
		}
		return returnType;
	}

	//Error handling
	struct Error {
		dstring msg, info;
		GrLexeme lex;
		bool mustHalt;
	}

	Error[] errors;

	void logWarning(string msg, string info = "") {
		Error error;
		error.msg = to!dstring(msg);
		error.info = to!dstring(info);
		error.lex = get();
		error.mustHalt = false;
		errors ~= error;
	}

	void logError(string msg, string info = "") {
		Error error;
		error.msg = to!dstring(msg);
		error.info = to!dstring(info);
		error.mustHalt = true;
		if(isEnd()) {
			error.lex = get(-1);
		}
		else
			error.lex = get();

		errors ~= error;
		raiseError();
	}

	void raiseError() {
		foreach(error; errors) {
			dstring report;

			//Separator
			if(error.mustHalt)
				report ~= "\n\033[0;36m--\033[0;91m Error \033[0;36m-------------------- " ~ error.lex.lexer.file ~ "\033[0m\n";
			else
				report ~= "\n\033[0;36m--\033[0;93m Warning \033[0;36m-------------------- " ~ error.lex.lexer.file ~ "\033[0m\n";

			//Error report
			report ~= error.msg ~ ":\033[1;34m\n";

			//Script snippet
			dstring lineNumber = to!dstring(error.lex.line + 1u) ~ "| ";
			report ~= lineNumber;
			report ~= error.lex.getLine().replace("\t", " ") ~ "\n";

			//Red underline
			foreach(x; 1 .. lineNumber.length + error.lex.column)
				report ~= " ";

			if(error.mustHalt)
				report ~= "\033[1;31m"; //Red color
			else
				report ~= "\033[1;93m"; //Red color

            auto lexLength = error.lex.textLength;
            if(error.lex.type == GrLexemeType.String)
                lexLength += 2;
			foreach(x; 0 .. lexLength)
				report ~= "^";
			report ~= "\033[0m\n"; //White color

			//Error description
			if(error.info.length)
				report ~= error.info ~ ".\n";
			writeln(report);
		}
		throw new Exception("\033[0mCompilation aborted...");
	}
}